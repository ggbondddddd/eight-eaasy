有时间看看具体的class类，

promise手写，

手写call，bind，apply

node的事件循环

具体cors如何实现跨域（这里我可以看nodejs实现方式）和nginx跨域

手搓一个防抖搜索框；

物理像素和px，两倍图，background-size

有时间好好看一下圣杯和双飞翼布局

有时间把路由守卫方面仔细看看

nodejs大概的express看看 ，

抽时间写一次倒计时时间戳，rgb颜色变字符串，还有除了快速排序和冒泡以外的其他排序

有时间去看一下webpack如何制作vue脚手架

搞清楚时间复杂度和空间复杂度怎么计算，栈和队列是啥，二分查找原理，斐波那契数列时间复杂度为毛为o（n的平方）



面试没回答好的地方：

我vue2响应式原理没回答好

虚拟dom使用我没有说他的作用你，

问了我 如何通过服务器返回回来的不同状态码，然后进入不同的页面，我回答的是利用axios的响应拦截器，应该是没说错的

问了前端请求头如何配置，我说的在axios的实例上，其实我说错了，应该是在axios的请求拦截器上，默认的参数上存在headers属性，

我们就可以利用这个配置token请求头



4月22日面试没有回答好的地方:

首先问了我适配 我回答了媒体查询,没有说流式布局;

水平垂直居中;

背景实现渐变色:我说的是用linea-grandient,应该是没说错的;

元素拖拽功能:我回答了用mousedown和mousemove和mouseup来做,我说的是配合pagex和pagey我觉得应该是说错了,首先我们需要被拖拽的那个元素需要脱离标准流,

箭头函数和一般函数的区别;

0.1+0.1为什么不等于0.2;这里我回答的不好,我说用数字的方法回答,那个什么方法来着,就是取数字几位小数那个;tofixed方法可以解决

双等和三等的区别;

深拷贝,我感觉讲原理的时候说的不太好,再去从新组织一下语言;

问了我跨域,我代理跨域说的一般般,我说错了一个地方,就是服务器和服务器之间是不存在跨域,所以我们用代理服务器实现跨域;

说coookie和回话,本地存储的区别;

问了路由中hash和history的区别,还问了我hash路由的原理,这是我不知道的;

还有一半的东西没有听

还问了nodejs

定时器是可以停止的吗;然后还完善了我的 倒计时是利用定时器做的,还问了个特殊情况,我没有考虑过这个情况;

还问了个问题,如果我点了个不同的路由,然后再页面显示个类似面包屑的东西,只要我一点击就可以跳转到这个路由,思路就是,我觉得可以再需要用到的地方,当我路由跳转时候,我就将这个路由地址push放到vuex仓库中去,用个数组去接收,然后类似导航栏,我遍历出来这个数组的面包屑按钮,当我点击就利用this.$router.push进行路由跳转即可

普通函数和箭头函数的区别;

问到了我图片的裁剪功能有做过吗;这个我不知道

单页面应用（Single Page Application，SPA）和多页面应用（MPA）的优点缺点；





hr面

未来三到五年的规划

首先当然是通过校招找到一份正式的前端开发的工作，当然能进贵公司这样的大平台是最好的，然后在毕业前能够提起到公司去实习，提前适应我未来工作的这家公司的工作环境，熟悉工作流程和公司经营的具体业务，让自己尽快的融入到公司里来，争取能够顺利转正，毕竟我真实的工作经验只有四个月，我希望在未来的时间里面可以接触到更多不同的业务，比如贵公司的智慧口岸，智慧机场这些业务都是我以前没有做过的，比如小程序端，手机端的业务，能够让自己具备多端开发的能力，在工作中遇到不懂得知识会在业余事件去学习，并且利用笔记的方式去记录工作中的一些心得，不断提升自己知识面的宽度和广度，比如在闲暇时间学习react，再去深入学习一下webpack和nodejs，以及vue的一些底层原理，不断地进步，争取能一年比一年技术更完善，最终能成为一名具备多端开发的前端开发工程师。



关于加班

我认为适度的加班是可以接受的，如果项目赶进度，需要比较高强度的加班，像这种情况我也是可以接受的，只要不是天天高强度的加班的话，就问题不大，我在实习的公司有时候需求没有写完的时候也会加班



自我介绍

面试官你好，我叫汪广通，来自文华学院的计算机科学与技术专业，是今年六月份的应届毕业生，我应聘的岗位是前端开发工程师。我有过一段四个月的前端开发的实习经历，在实习过程中我主要的工作就是通过项目经理提的需求，以及ui设计的原型图复现页面，然后和后端协调接口字段，对接口，然后改一些客户提出的bug，需求，自己也有做过几个模块。我本人性格外向，有一定的抗压能力，在工作中遇到困难，不会轻易放弃，会通过各种方式寻找解决办法，并且和同事之间可以和睦相处，会服从领导的安排。我的自我介绍完毕，面试官看看您有什么想问的。



为什么离开上一家实习的公司

因为上一家公司采用的是公司自研的低代码平台开发，我本人可能并不是那么喜欢这种方式，我还是更偏向于直接用vscode写代码，同事和领导都是很好的，我只是自己觉得长远考虑，所以就选择离开了。



手上还有其他offer吗

还有一个7k十三薪的offer在武汉，不过并没有签三方，当然这家公司和贵公司相比在规模上还是不如贵公司的，所以我当然是跟向往能在贵公司工作，毕竟贵公司是一个更加大的平台，我觉得平台还是比较重要的，在更大的公司可以接触到更多不同的业务，可以让我见识到更多东西，我觉得这是非常有价值的。



关于公司的了解

贵公司总部在深圳，主要从事人工智能，大数据，物联网等方面高新技术的研究，为客户提供更贴近实际需求和符合未来发展趋势的智能产品和'ai+行业解决方案'，是国家级的高新技术企业，在智慧口岸查验系统方面有非常深入的研究以及非常高的行业认可度，并且基于智慧口岸领域的技术积累，以及将业务拓展到了智慧交通，智慧边检，智慧边检等其他领域。还是深圳市五百强企业。



遇到过最大的困难

送外卖，大一的寒假有想自己赚一点零花钱，所以就去送外卖，大概是一月中旬，那天晚上下着大雨，送外卖就是一下雨就会爆单，就是很多人点外卖，然后你手上会有好多单外卖，然后在送某一单的路特别烂，因为刚好在修路，路上全是坑坑洼洼，特别难走，当时好几单都要超时了，所以我本身就已经有些着急了，但是当我沿着这条烂路骑了快两公里的时候我发现因为修路前面被施工的那种铁皮拦住了，过不去了，我需要从新返回去然后再换一条路送这一单，当时我就崩溃了，都已经想着今天送完再也不送外卖了，然后没办法，我只能自己快速调整平复心态，然后给顾客把餐送到了，虽然最后超时了很多单，但是顾客人都不错，没有给我差评，因为给差评会扣钱，这可能是我真的经历的特别无助的一次，不过经历过后还是有成长的。



反问

请问这是最后一轮面试吗，什么时候可以知道最后的结果

请问大概实习薪资还有转正薪资是怎么来的，然后可以签三方吗，实习期可以抵扣试用期吗

其他的问题我在前面两轮已经有问过面试官了，没有别的想问的了



#### 时间复杂度（时间需要累计）

其实时间复杂度有最好时间复杂度，最坏时间复杂度，平均时间复杂度，一般我们说的都是最差时间复杂度，因为我们不知道具体给我们的数据是什么样的，就比如一个有序数组的冒泡排序时间复杂度其实是O(n),但是一般我们还是会说O(n的平方)

常数阶：函数内循环为常数次或者没有循环,例如下面第一题,时间复杂度为O(1)

线性阶：就像上面第二题一样,只有一层循环,时间复杂度随n的增大线性增加,函数在图像上表示为一条经过原点的直线,O(N).

对数阶：下方第四题

指数阶：一般是多层循环的嵌套,例如下面题三中,最大是两层n次循环的嵌套因此`时间复杂度为O(N^2),n的平方次,要是三层n次循环的嵌套则为O(N^3)，反正什么什么次方就是指数

线性对数阶：就是将对数阶的代码循环n遍，所以时间复杂度就是n*O(logN)

https://blog.csdn.net/m0_63850771/article/details/127229462

```js
//例如这个代码时间复杂度其实就是O(1),这个1不是指一次，而是指常数次，不管我们输入的n多大，永远都执行100次，所以是o(1)
int fun(int n)
{
  int i = 0;int cnt = 0;
   for( i; i<100;i++)
     {
       cnt++;
      }
  return cnt;
}

//时间复杂度为o(n)
for (int i = 0; i < n; i++) {
	 j = i;
   j++;
}

//时间复杂度为o(n的平方)，当我们的循环不断的嵌套，就会变成n的立方，n的四次方
for(x=1; i<=n; x++){
   for(i=1; i<=n; i++){
       j = i;
       j++;
    }
}

//在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了，直到i不小于n退出。我们试着求解一下，假设循环次数为x，也就是说 2 的 x 次方等于 n，则由2^x=n得出x=log₂n。因此这个代码的时间复杂度为O(logn)
int i = 1;
while(i<n)
{
    i = i * 2;
}

//
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}

//如这个斐波那契数组时间复杂度就是O(2的n次方)
int Fibonacci(int number)
{
    if (number <= 1) return number;

    return Fibonacci(number - 2) + Fibonacci(number - 1);
}

```

#### 空间复杂度（空间不需要累计，可复用）

https://blog.csdn.net/vpurple_/article/details/126018218

空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度 ，也就是额外占取的空间的大小。

如此处冒泡排序空间复杂度为O（1）

![image-20240427122335453](assets/image-20240427122335453.png)

#### 斐波那契数列

![image-20240427123344476](assets/image-20240427123344476.png)

#### 二分查找

为什么左下标等于右下标不退出循环https://blog.csdn.net/qq_45978890/article/details/116094046

注意：二分查找的前提是数组是有序的

二分查找的本质就是在有序数组中进行循环，首先确定中间值为左下标和右下标之间的中间值，左下标初始为0，右下标初始为数组的末尾下标也就是arr.length-1,然后比较中间下标值和目标值大小，如果中间值大于目标值，我们就可以说中间下标及其之前下标的值全部小于目标值，所以我们可以让右下标等于中间下标-1；如果中间值小于目标值，说明目标值在中间值的右边，所以让左下标等于中间下标+1；就这样一直循环，中间下标和左右下标不断变化，当出现中间值等于目标值就返回出去，如果一直到左下标等于右下标说明全部数组比较完毕，退出循环，返回-1，说明该数组中不存在目标值。

```js
function find(arr,target){
    //初始的左下标
  let left=0
  //初始右下标
  let right=arr.length-1

  //因为不确定循环的次数，所以使用while
  //此处一定要是小于等于，因为出现中间下标为左下标，而目标值在右下标这种情况时，因为中间值还是小于目标值，所以左下标等于中间下标+1，此时左下标等于右下标
  while(left<=right){
    //初始中间下标，这个下标是向下取整或向上都无所谓
    let mid=Math.floor((left+right)/2)
    if(arr[mid]>target){
      right=mid-1
    }else if(arr[mid]<target){
      left=mid+1
    }else{
      return mid
    }
  }
  //没有找到目标值
return -1

}
console.log(find([1,2,3,4,5,6],4))
```

**为何左下标等于右下标的时候不退出循环，如下**

如果目标值为27，数组如下

![image-20240427135811562](assets/image-20240427135811562.png)

![image-20240427135826421](assets/image-20240427135826421.png)

![image-20240427135840514](assets/image-20240427135840514.png)

![image-20240427135849597](assets/image-20240427135849597.png)

![image-20240427135857356](assets/image-20240427135857356.png)

![image-20240427135907378](assets/image-20240427135907378.png)

此时middle等于6，此时nums[middle]=22，依然小于目标值27，所以此时左下标等于middle+1，等于7，而右下标也等于7，如果此时直接跳出循环，返回-1，就是没有找到目标值，而实际上目标值就是下标为7的那个值，所以判断跳出循环条件不能包含左下标等于右下标。

### html和css

#### 1.html5的新特性

https://blog.csdn.net/weixin_45709829/article/details/115433620

web worker

**web worker的一些限制**

1.存在兼容性问题,不是所有浏览器都支持，尤其是一些旧版的浏览器可能不支持 Web Worker。使用前可以判断一下

使用代码if (typeof(Worker) !== "undefined"){}进行判断.

2.只能通过网络加载 JavaScript 文件，无法直接加载本地文件

3.分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源

https://blog.csdn.net/weixin_44380380/article/details/130552704



#### 2.css3的新特性

过渡；

谁过渡就给谁加transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)

动画

animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）然后设置一个关键帧@keyframes ，通过0%到100%设置不同的动画效果实现

transform转换 translate，rotate，scale ；可以利用transform-orgin设置转换的初始位置

新增了很多选择器，结构伪类选择器如nth-child，nth-of-type，伪类选择器：：before，：：after，：：hover，属性选择器等；

https://blog.csdn.net/weixin_54007670/article/details/127908932

盒子阴影box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里）;

文字阴影text-shadow:水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。

边框圆角；https://blog.csdn.net/qq_46048008/article/details/126406331

flex布局；

渐变：linear-gradient

颜色rgba  最后一个参数表示的是透明度

媒体查询做响应式布局（不是css3新特性，注意）

![image-20240313160822638](assets/image-20240313160822638.png)





#### 3.js的数据类型，js数据类型的判断

基本数据类型：Number，String，Boolean，Undefined，Null，Symbol

引用数据类型：array，obj，function，set，map

1.typeof只能判断基本数据类型，null会被判断为object；

2.instanceOf只能判断引用数据类型，且数组也会被判断为对象，虽然这是没错的，但是比如在手写深拷贝的时候需要注意，且undefined和null不能判断，例如 a instanceof b，因为instanceof是判断a是否为instanceof原型链上的构造函数;

3.Object.prototype.toString.call() 是最全面的。而 a.constructor ==b 来判断a的类型，的这个constructor其实也是原型链上其实完整的写法是a.--prototype--.constructor;因为原型链的关系，a上面没有constructor这个属性，就会沿着a的构造函数的prototype去查找，所以这里用的实际是实例对象的constructor属性

#### 4.常用的盒子水平垂直居中方法，子绝父相和flex布局实现即可

#### 5.回流（重排）和重绘

当DOM的变化影响了元素的几何信息(DOM对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做回流（重排）

当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘，改变元素的color，background，box-shadow等属性

**如何减少回流和重绘**

1.使⽤ transform：translate 替代 子绝父相后移动right，left，top，bottom

2.使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）

3.不要把 DOM 结点的属性值放在⼀个循环⾥当成循环⾥的变量

```js
for(let i = 0; i < 1000; i++) {
 // 获取 offsetTop 会导致回流，因为需要去获取正确的值
 console.log(document.querySelector('.test').style.offsetTop)
}
```



#### 6.盒子模型

  常规是box-sizing：content-box；当设置了内边距和边框会撑大盒子  奇异盒模型：box-   sizing：border-box；内边距和边框都包含再盒子的尺寸里面

#### 7.清除浮动的方法：  	

![image-20240407170221409](assets/image-20240407170221409.png)

#### 8.圣杯和双飞翼布局

就是常见的两侧固定，然后中间自适应，用felx布局可以很轻松实现，左右两侧写死宽度，中间的盒子flex:1，就是剩余的宽度全部给中间盒子，而利用order属性即可解决中间部分可能被两侧遮挡的问题；利用浮动比较不好实现

![image-20240228164103424](assets/image-20240228164103424.png)

#### 9.请列举几种隐藏元素的方法

· visibility: hidden;这个属性只是简单的隐藏某个元素，但是元素占用的空间仍然存在
· opacity: 0; CSS3属性，设置0可以使一个元素完全透明，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的
· display: none;元素会变得不可见，并且不会再占用元素位置。会改变页面布局。
· transform: scale(0);将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留。

#### 10.let，const，var的异同点

https://blog.csdn.net/weixin_57677300/article/details/126617174

**let**和**const**具有块级作用域，**var**不存在块级作用域,可以跨块访问, 不能跨函数访问

var存在变量提升，let和const不存在变量提升，变量能在声明之前使用，就是变量提升

var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量

在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值

let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

```js
// 使用 const 关键字定义衡量，const 限制的是给衡量分配值的动作，并不限制衡量中的值，如下操作都是可以的
const app = ['☃️', '🌈']
        console.log(...app)
        app.push('🤣')
        console.log(...app)
        app[0] = 1
        console.log(app);
//但是如果你给常量从新分配一个值就错了，这就是错的
app=10
```

#### 11.css优先级

!important > 内联 > ID 选择器 > 类选择器 > 标签选择器。

#### **12.外边距塌陷问题解决办法**（这里和下方BFC一起看 BFC就可以解决这个问题）

产生原因:1.父子元素，给子元素一个margin-top=50px，我们想要的效果是子元素距离父元素顶部50px，但是实际上效果是图2，父子元素一起距离顶部50px；2.同级元素，垂直方向上方那个div设置下外边距，下方那个div设置上外边距，实际的距离不是两者之和而是两个外边距中大的那个外边距

父子级元素如下

![img](assets/56172f8762a34f899c844976bde74543.png)

这里我们知道了 设置BFC区域后，子元素相对于父元素也是独立的

![image-20240228174303745](assets/image-20240228174303745.png)

解决方案:

1. 给父元素加边框`border`

2. 给父元素加内边距`padding`

3. 给父元素加`overflow:hidden`（这个貌似就是BFC原理实现的）

   两同级元素遇到外边距合并解决办法

   ![image-20240228173537658](assets/image-20240228173537658.png)

   让这两个元素都变为BFC即可，也就是两个元素都分别加一个父元素，都加一个overflow：hidden

   ![image-20240228173724770](assets/image-20240228173724770.png)

#### **13.BFC(`Block Formatting Context `的缩写，即块格式化上下文)**

如何使一个元素变为BFC区域：

·设置浮动，也就是display:left和display:right可以而display：none不行
·设置定位，absoulte或者fixed
·行内块显示模式，inline-block
·设置overflow，即hidden，auto，scroll，只有visable不行
·表格单元格，table-cell

·弹性布局，flex

**BFC作用 （解决了什么问题）**

1. 阻止margin重叠（就是上面12的会导致外边距塌陷的两种情况）

2. 可以包含浮动元素 —— 清除内部浮动

3. 自适应两栏布局，

4. 可以阻止标准流元素被浮动元素覆盖  （**3和4是一样的，如下）**

   ![image-20240228175722625](assets/image-20240228175722625.png)

   ![image-20240228175742211](assets/image-20240228175742211.png)

   

![img](assets/7c1bf9470b8b4d6a99bb2ea124ff5c15.png)

假设box1和box5是两个BFC区域，那么根据上述原理能理解到的就是，box1这个BFC区域包含了子元素box2，box3，box4，box5。但不包括box678。而box5这块BFC区域则包含了box678这三个子元素。

总结:
1,每一个BFC区域只包括其子元素，不包括其子元素的子元素。
2,每一个BFC区域都是独立隔绝的,互不影响
第一条就是字面意思，第二条直接看代码理解



#### **15.垃圾回收机制和内存机制**

垃圾回收

浏览器的js具有自动垃圾回收机制，垃圾回收机制也就是自动内存管理机制，垃圾收集器会定期的找出那些不在继续使用的变量，然后释放内存。但是这个过程不是实时的，因为GC开销比较大并且时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

**内存泄露（关于这个问题我收藏在掘金）**

如果 那些不再使用的变量，它们所占用的内存 不去清除的话就会造成内存泄漏

内存泄露其实就是我们的程序中已经动态分配的堆内存，由于某些原因没有得到释放，造成系统内存的浪费导致程序运行速度减慢甚至系统崩溃等严重后果。

比如说：

1、不正当的闭包：在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收（GC）。

![image-20240229150517976](assets/image-20240229150517976.png)

![image-20240229150553122](assets/image-20240229150553122.png)

![image-20240229150609225](assets/image-20240229150609225.png)

2、DOM：当原有的DOM被移除时，这个dom的子结点引用没有被移除则无法回收

![image-20240229150751933](assets/image-20240229150751933.png)

3、遗忘的定时器

![image-20240229151435832](assets/image-20240229151435832.png)

4.隐式全局变量,就是没有用let const声明的变量

**解决内存泄漏的方法**

1. 变量先声明后使用。

2. setTimeout setInterval清理 （最好不用）可以使用nextTick代替。

3. 如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理。

   mounted () { window.addEventListener('resize', this.onResize) }, beforeDestroy () { window.removeEventListener('resize', this.onResize) }

4. 如果在mounted/created 钩子中使用了on，需要在beforeDestroy 中做对应解绑(off)处理。

   mounted () { this.EventBus.EventBus.EventBus.on('exitClassRoom',this.exitClassRoomHandle) }, destroyed () { this.EventBus.EventBus.EventBus.off('exitClassRoom',this.exitClassRoomHandle) }

5. 如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理。

6. 慎用keep-alive
   当你用 keep-alive 包裹一个组件后，它的状态就会保留，因此就留在了内存里，切莫在整个路由页面上加上keep-alive。
   一旦你使用了 keep-alive，那么你就可以访问另外两个生命周期钩子：activated和 deactivated。你需要在一个 keep-alive 组件被移除的时候，调用 deactivated 钩子进行清理或改变数据。







#### **16.作用域**

1、作用域

作用域就是一个变量可以使用的范围，主要分为全局作用域和函数作用域，以及es6提出的块级作用域。

全局作用域就是Js中最外层的作用域

函数作用域是js通过函数创建的一个独立作用域，函数可以嵌套，所以作用域也可以嵌套

Es6中新增了块级作用域（由大括号包裹，比如：if(){},for(){}等）

2、自由变量

当前作用域外的变量都是自由变量，一个变量在当前作用域没有定义，但是被使用了，就会向上级作用域，一层一层依次查找，直至找到为止，如果全局作用域都没有找到这个变量就会报错。这个自由变量查找的过程就是作用域链。

3、变量提升（通俗讲就是可以先赋值再声明）

每个var声明的变量，function声明的函数存在变量提升。let const不存在变量提升

在js中声明之前未定义，会在js的最上方会形成一个预解析池，用来存储声明了但没有先定义的变量名

4、作用域链

当一个变量在内部就有时就不需要使用到作用域链， 作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是`作用域链`。



#### **17.事件循环**（下面有看渡一课的笔记）

首先js的运行机制是单线程，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个，单线程就是所有的任务放在一个主线程上，前面的任务没有完成，后面的任务就必须一直等待，同步任务就是这样执行的。而事件循环是单线程的JavaScript在处理异步事件时进行的一种循环过程。也就是说事件循环是异步实现的方式。

执行流程：

1.在代码执行的时候，所有同步任务（所谓同步任务，就是非耗时任务，在主线程当中直接执行的任务，如console.log或变量加减之类的）都在主线程上执行，形成一个函数调用栈（执行栈）

2.主线程之外，还存在一个‘任务队列’（task queue），浏览器中的各种 Web API 为异步的代码提供了一个单独的运行空间，当异步的代码运行完毕以后，会将代码中的回调送入到 任务队列中，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务放入到微任务队列中

3.一旦主线程的执行栈中的所有同步任务执行完毕后，调用栈为空时系统就会优先将任务队列中的异步微任务压入调用栈中执行，当异步微任务执行完，再将异步宏任务压入执行栈中执行，只要调用栈为空，就会不断循环检测任务队列中是否有代码需要执行，一直循环直到所有任务执行完毕

其中：微任务包括了 promise .then，node 中的 process.nextTick 。宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。

**面试题：如何理解 JS 的异步？**

参考答案：

JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行

**JS为何会阻碍渲染？也就是为什么我们操作dom后不是立马更新**

```html
<h1>Mr.Yuan is awesome!</h1>
<button>change</button>
<script>
  var h1 = document.querySelector('h1');
  var btn = document.querySelector('button');

  // 死循环指定的时间，这是
  function delay(duration) {
    var start = Date.now();
    while (Date.now() - start < duration) {}
  }
//这个点击事件属于交互队列，当点击后会将后面回调放入到交互队列中去
  btn.onclick = function () {
    h1.textContent = '袁老师很帅！';
    delay(3000);
  };
</script>
```

![image-20240411124318204](assets/image-20240411124318204.png)



### 任务有优先级吗？

任务没有优先级，在消息队列中先进先出

但**消息队列是有优先级的**

根据 W3C 的最新解释（舍弃了宏任务的概念，因为任务的类型太多了）:

- 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。
  在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
- 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行
  https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint

> 随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法
>
> 在目前 chrome 的实现中，至少包含了下面的队列：
>
> - 延时队列：用于存放计时器到达后的回调任务，优先级「中」
> - 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」，比如滚动滚动条，鼠标事件，点击事件，鼠标移入移出事件等，键盘事件，缩放窗口
> - 微队列：用户存放需要最快执行的任务，优先级「最高」
>
> > 添加任务到微队列的主要方式主要是使用 Promise、如Promise.resolve().then(函数)会立刻将这个then里面的回调加入到微队列中，MutationObserver
> >

如下例子（注意点是必须已有所有微任务执行完，再去执行交互队列或者延时队列，这两个队列其实就是宏任务队列，）

```js
function a() {
  console.log(1);
  Promise.resolve().then(function () {
    console.log(2);
  });
}
setTimeout(function () {
  console.log(3);
}, 0);

Promise.resolve().then(a);

console.log(5);

//运行结果是5 1 2 3 ，一步步来 ，首先运行那个定时器 ，当0秒后将定时器的这个回调函数放到延时队列，然后运行promise.then，将函数a放入到微队列，然后运行渲染主进程上同步任务打印5， 然后主线程为空，将微队列放入渲染主线程执行，打印1，然后将函数放入到任务微队列，然后此时再将这个微队列中的打印2执行，最后执行延时队列中的打印3


//如下运行结果是 5 1 2 3 10 9  可以看看逻辑 
   function a() {
            console.log(1)
            Promise.resolve().then(function () {
                console.log(2)
            })
            setTimeout(() => {
                console.log(9)
            }, 0)
        }
        setTimeout(function () {
            console.log(3)
            Promise.resolve().then(function () {
                console.log(10)
            })
        }, 0)

        Promise.resolve().then(a)

        console.log(5);
```

> 面试题：阐述一下 JS 的事件循环（这里和我自己总结有区别，可以记忆这个）
>
> 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
>
> 在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
>
> 过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
>
> 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。

> 面试题：JS 中的计时器能做到精确计时吗？为什么？
>
> 不行，因为：
>
> 1. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差
> 2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差

#### **18.dom和bom**（看csdn收藏在js八股文里的文章）

如果要我描述dom和bom,我可以这样说。首先JavaScript由dom和bom和ECMAscript三者构成，其中ECMAscript是JavaScript在浏览器执行的标准

DOM（Document Object Model是指文档对象模型，是为了操作（xml，html）文档出现的接口**。**为JavaScript提供了一种访问和操作HTML元素的"方法"。document.querySelect不属于dom提供的操作dom元素的方法，是另外一种规范提供的。在浏览器解析HTML标签时，会构建一个DOM树结构。根节点是document对象

BOM 是 Browser Object Model，浏览器对象模型。BOM 是为了控制浏览器的行为而出现的接口。为JavaScript提供了一种控制浏览器行为的"方法"。并且dom树也会映射到bom的document对象上

关于JavaScript中DOM的一些常见的操作html元素的方法

获取节点的DOM方法

```js
//1.通过元素的id属性值来获取元素，返回的是一个元素对象
var element = document.getElementById(id_content)

//2.通过元素的name属性值来获取元素，返回的是一个元素对象的数组
var element_list = document.getElementsByName(name_content)

//3.通过元素的class属性值来获取元素，返回的是一个元素对象的数组
var element_list = document.getElementsByClassName(class_content)

//4.通过标签名获取元素，返回的是一个元素对象数组
var element_list = document.getElementsByTagName(tagName)
```

创建节点(Node)的DOM方法

```javascript
//1.创建一个html的元素，传参是元素类型，例如div、h1-5、a，下以div为例
var element = document.createElement("div")
```

增添节点的DOM方法

```js
//1.向element内部的最后面添加一个节点，传入的参数是节点类型
element.appendChild(Node)

//2.向element内部某个已存在的节点的前面插入一个节点，仍然传入一个节点类型的参数
element.insertBefore(new_Node,existed_Node)
```

删除节点的DOM方法

```javascript
//删除element内的某个节点，传参是节点类型参数
element.removeChild(Node) 
```

DOM常见的一些属性
最后是一些常见的DOM属性：

```js
//1.获取当前元素的父节点
var element_father = element.parentNode

//2.获取当前元素的html元素型子节点
var element_son = element.children

//3.获取当前元素的所有类型子节点，包括html元素、文本和属性
var element_son = element.childNodes

//4.获取当前元素的第一个子节点
var element_first = element.firstChild

//5.获取当前元素的前一个同级元素
var element_pre = element.previousSibling

//6.获取当前元素的后一个同级元素
var element_next = element.nextSibling

//7.获取当前元素的所有文本，包括html源码和文本
var element_innerHTML = element.innerHTML

//8.获取当前元素的所有文本，不包含html源码
var element_innerTEXT = element.innerText
```

Bom

![image-20240301100111956](assets/image-20240301100111956.png)

**window对象**

从上面这张图上，我们可以看到：

> **window是整个BOM树食物链的顶端**，因此**每一个新打开的窗口，都被认为是一个window对象。**最常用的有setInterval和setTimeout这两个定时器，还包含操作dom的document对象，
>
> 还有alert(string)：创建一个警示框；close()：关闭窗口

Location对象：常用的方法如window.location.href（）可以实现网页的跳转

🌳history对象
什么是history对象？

history 对象是 window 对象的属性，它保存着用户上网的记录，这个记录的时间戳是从窗口被打开的那一刻算起。

history对象有以下常见的属性和方法：

属性/方法	描述
length	history 对象中的记录数
back()	前往浏览器历史条目前一个 URL，类似后退
forward()	前往浏览器历史条目下一个 URL，类似前进
go(num)	浏览器在 history 对象中向前或向后

🌳navigator对象
最后介绍一下navigator对象：

navigator对象，是BOM中识别客户端浏览器的一个window属性。

与navigator相关的一些常见属性：

属性	说明
appName	完整的浏览器名称和版本信息
platform	浏览器所在的系统平台
plugins	浏览器中安装的插件信息的数 组
userAgent	浏览器的用户代理字符串
userLanguage	操作系统的默认语言

#### **19.箭头函数**

js中我们在调⽤函数的时候经常会遇到this作⽤域的问题，这个时候ES6给我们提箭头函数。

1、 箭头函数是匿名函数不能作为构造函数，不能使用new

2、 箭头函数不绑定arguments,取而代之用rest参数…解决

3、 this指向不同,箭头函数的this在定义的时候继承自外层第一个普通函数的this

5、 箭头函数没有prototype(原型)，所以箭头函数本身没有this

6、 箭头函数不能当做Generator函数,不能使用yield关键字、

7、 写法不同，箭头函数把function省略掉了 （）=> 也可以吧return 省略调 写法更简洁

8、箭头函数不能通过call（）、apply（）、bind（）方法直接修改它的this指向。

补充：谈一下arguments剩余参数和rest参数和拓展运算符的区别

```js
//动态参数（es5），是类数组对象，和数组的相同点在于有length长度，其他的都不一样，只是和数组长得像，属性名是系统自动生成的字符串0，1，2 依次类推
function test() {
   console.log(arguments);
}
test(2, 5, 3) // [2, 5, 3]的伪数组 结果如下

```

![image-20240301145137536](assets/image-20240301145137536.png)

```js
//剩余参数长得和拓展运算符一样，是es6提出的取代动态参数的更优解，因为rest参数是一个真数组，可以使用数组的方法，动态参数是伪数组，无法使用数组的方法。
function test2(...values) {
  console.log(values);
}
test2(2, 5, 3) // [2, 5, 3]   结果如下
```

![image-20240301145316271](assets/image-20240301145316271.png)

```js
//数组的扩展运算符相当于 rest 参数的逆运算，如上rest参数是把逗号分隔的参数序列转化为了一个数组，而数组的扩展运算符是将一个数组转为用逗号分隔的参数序列。注意：扩展运算符可以将单层的数组或对象实现深拷贝，Object.assign（）方法也可以
console.log(...[1, 2, 3]) // 1 2 3
//常用于合并参数，如下
[...[1,2,3], 4] // [1, 2, 3, 4]

//对象的扩展运算符等同于使用Object.assign()方法，如下两种写法是等价的
let aClone = { ...a };
let aClone = Object.assign({}, a);
//扩展运算符可以用于合并两个对象,如下是等价的
let ab = { ...a, ...b };
let ab = Object.assign({}, a, b);


```

#### 20.this指向

this的指向主要有下面几种：

1、this出现在全局函数中,永远指向window

2、 严格模式下this会指向 undefined

3、当某个函数为对象的一个属性时，在这个函数内部this指向这个对象

4、this出现在构造函数中，指向构造函数实例对象

5、当一个元素被绑定事件处理函数时，this指向被点击的这个元素

6、this出现在箭头函数中时，this是外层最近的一个this

7.重点，闭包中函数的this还是window，哪怕是对象中函数的闭包，这个闭包this依然是window，除非你用call改变这个this指向

```js

var gg=2
   function a(){
       var gg=1
       console.log('a',this)//此处this是window
     return  function b(){
           console.log('b',this)//此处的this是winodw，不是a这个函数
         console.log(this.gg) //此处的gg是最外层的2 ，而不是1，因为这里的this是window，且如果用let或const声明的gg我们this获取到的就是undefined，因为只有用var声明的变量才是全局window的属性，let和const声明的属于块级作用域而不是全局作用域
       }
   }
 a()()

//这是一个对象
   let obj1={
       j:function (){
           console.log('j',this)//这里this是obj1这个对象
           return function (){
               console.log(this)//这里this不是obj1，而是window
           }
       }
   }
obj1.j()()
```



#### **21.数据类型存储以及堆栈内存是什么**（有助于理解引用数据类型）

基本数据类型：直接存储在栈内存中，占据空间小，大小固定，属于被频繁使用的数据。指的是保存在栈内存中的简单数据段；number string 布尔

引用数据类型：同时存储在栈内存与堆内存中，占据空间大，大小不固定。

引用数据：类型将指针存在栈中，将值存在堆中。 当我们把对象值赋值给另外一个变量时，复制的是对象的指针，指向同一块内存地址，意思是，变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值，数组 对象
堆(heap)和栈(stack)有什么区别存储机制
栈： 是一种连续储存的数据结构，具有先进后出后进先出的性质。

通常的操作有入栈（压栈），出栈和栈顶元素。想要读取栈中的某个元素，就是将其之间的所有元素出栈才能完成。

堆：  是一种非连续的树形储存数据结构，具有队列优先,先进先出； 每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。



#### **22.事件冒泡和事件捕获（面试官问到我事件流，其实问的就是这个），我收藏的那个js笔记里面讲的很清楚**

很好的JavaScript笔记：https://zh.javascript.info

微软（IE）和网景（Netscape）开发团队提出了两个截然相反的事件流概念，**IE的事件流是事件冒泡流**，而**Netscape的事件流是事件捕获流**。

**事件委托，**又名事件代理。事件委托就是利用事件冒泡，就是把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托也就没法实现了. event.stopPropagation() 可以阻止冒泡，在addeventListener里面的定义的函数后面加上一个true，或者capture：true，就会开启事件捕获，然后事件冒泡就会被关闭，默认是false关闭的状态



#### **23.防抖和节流**(需要会手搓)

防抖：**所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。**通俗讲就是只执行最后一次，比如在点击某个按钮发起网络请求，如果点击多次会发多次，浪费性能

```js
 //这是利用了闭包的写法,这个timer就是闭包，其实可以放在这个函数外面，那么time就不是闭包了，而且需求依然可以实现  需求：触摸屏幕 只有最后一次会让i增加
const box = document.querySelector('.box')
        let i = 1
        function mouseMove() {
            box.innerHTML = i++
        }
       // let timer //放在这里就不属于闭包了
        function debounce() {
             let timer //放在这里属于闭包
            return function () {
                if (timer) { clearTimeout(timer) }
                timer = setTimeout(function () {
                    mouseMove()
                }, 1000)
            }
        }
        // 这里之所以 debounce需要在鼠标移动事件直接调用是因为里面有return,你调用以后才会return你真正要调用的函数
        box.addEventListener('mousemove', debounce())

//这是没有使用闭包的写法 实现效果是一样的
     const box = document.querySelector('.box')
        let i = 1
        function mouseMove() {
            box.innerHTML = i++
        }
        let timer
        function debounce() {
            clearTimeout(timer)
            timer = setTimeout(function () {
                mouseMove()
            }, 1000)
        }
        box.addEventListener('mousemove', debounce)
```



节流：**所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。两种方式可以实现，分别是时间戳版和定时器版。**通俗讲就是规定时间内永远只会执行一次，比如轮播图

```js
 //原理 设置一个节流阀 当timer为假时把定时器赋值给timer，timer就为真了，也就进入了if判断，然后切记当定时器执行完后要给timer从新赋值undefined或null或0让他变为假，这样下次定时器才可以继续执行，注意清除定时器并不会让timer变为假
const box = document.querySelector('.box')
        let i = 1
        function mouseMove() {
            box.innerHTML = `${i}`
            i++
        }

        function throttle() {
            let timer
            return function () {
                if (!timer) {
                    timer = setTimeout(function () {
                        mouseMove()
                        // 当计时器执行完成让timer继续变成0 这样就可以再次执行计时器
                        timer = null
                        console.log(timer)
                    }, 1000)
                }
            }
        }
        // 添加滑动事件 滑动到一秒才数字才变化一次
        box.addEventListener('mousemove', throttle())
```



#### 24.浅拷贝和深拷贝

在理解深浅拷贝之前要知道，基本数据类型：直接存储在栈内存中；引用数据类型：同时存储在栈内存与堆内存中，引用数据的指针存在栈中，将值存在堆中。所以当你直接将对象赋值给其他对象，你给的其实是栈中的内存地址，而不是堆中具体的值

直接赋值，基本数据类型直接赋值过后互相不影响；而对象或数组直接赋值，两个对象或两个数组之间是相互受影响的；’

浅拷贝：当对象或数组内部没有子对象或子数字，只有基本数据类型，也就是单层对象或数组的时候，浅拷贝的的对象和数组与原数组之间互不影响，而原数组或对象内部还有子对象或子数组时，就会相互影响。实现浅拷贝的方式：遍历 ，扩展运算符... 还有函数可以用concat方法，对象可以用Object.assgin方法实现。

深拷贝：多层数组或对象就要使用深拷贝才能实现互不影响，方法如下

```js
 const arr1 = [1, 2,[1,2], 3, 4]
     const   arr2=[]
        const obj1 = { name: '张三', minObj: { age: 12, people: { num: 10 } }, hobby: '篮球' }
        // 这里我长一个教训，我刚开始只是创建了一个obj，但是没有赋值空对象，所以一直报错说obj2的某个属性不存在
        let obj2={}

// 方法1 ，这个方法不推荐使用，因为需要你提前定义一个变量，用方法2
        function deepClone1(clone, newthing) {
            for (let item in clone) {
                if (clone[item] instanceof Array) {
                    newthing[item] = []
                   deepClone1(clone[item], newthing[item])
                } else 
                if (clone[item] instanceof Object) {
                    newthing[item] = {}
                   deepClone1(clone[item], newthing[item])
                } else {
                    newthing[item] = clone[item]
                
                }
            }
            // return newthing
        }
 deepClone1(obj1, obj2)
        obj2.name='李四'
        console.log(obj1);
        console.log(obj2)

        deepClone1(arr1,arr2)
        arr2[1]=100
        console.log(arr1);
        console.log(arr2);



        const arr3 = [1, 2,[1,2], 3, 4]
        const obj3 = { name: '张三', minObj: { age: 12, people: { num: 10 } }, hobby: '篮球' }
       
        // 深拷贝方法2： 这个方法更合理比方法1，可以直接省去子属性再去判断是否为数组，因为对象包含了数组，并且使用的枚举[],赋值数组对象都成立
        // 以后就用这种方法
        function deepClone2(clone) {
            let newThing=clone instanceof Array ? [] :{}
            for (let item in clone) {
                // if (clone[item] instanceof Array) {
                //     newThing[item]=deepClone2(clone[item])
                // } else 
                if (clone[item] instanceof Object) {
                    //这个地方格外注意啊，对象的属性还是对象的时候，进入递归 你得把递归完成的值赋给他才行
                    newThing[item]= deepClone2(clone[item])
                } else {
                    newThing[item] = clone[item]
                }
            }
            return newThing
        }
      let obj4=  deepClone2(obj3)
      obj4.a=1
      console.log(obj3);
      console.log(obj4);
      let arr4=deepClone2(arr3)
    //   arr4[0]=999
      console.log(arr3);
      console.log(arr4);

//深拷贝方法3：原理是首先对象是复杂数据类型 把对象转换成字符串 字符串是简单数据类型 存的就不是地址而直接是一个值，然后再把这个字符串转换成对象，那么就会新开辟一个空间存储这个对象 这个对象就和之前那个对象存在两个不同地方 互不影响 这也就是深拷贝的本质
        const obj = {
            uname: 'pink',
            age: 18,
            hobby: ['乒乓球', '足球'],
            family: {
                baby: '小pink'
            }
        }

        // 把对象转换为JSON字符串
        // console.log(JSON.stringify(obj))
        // 把JSON字符串转换为对象
        const o = JSON.parse(JSON.stringify(obj))
        console.log(o)
        o.family.baby = '123'
        console.log(obj)
```

#### 25.原型链

原型链是一种查找规则是，一个用来实现继承和共享属性的有限的对象链。**获取对象属性时，如果对象本身没有这个属性，那就会去他的原型`__proto__`上去找，如果还查不到，就去找原型的原型，一直找到最 顶层(`Object.prototype`)为止。Object.prototype对象也有proto属性值为null。链式查找机制叫原型链。**

每个函数都有一个prototype属性，被称为显示原型

每个实例对象都会有_ _proto_ _属性,其被称为隐式原型

每一个实例对象的隐式原型_ _proto_ _属性指向自身构造函数的显式原型prototype

每个prototype原型都有一个constructor属性，指向它关联的构造函数。

还有一个点就是某个函数可能同时是某个实例对象的构造函数，也可能是某个构造函数的实例对象，**万物皆对象，函数也是对象**



![image-20240302161534635](assets/image-20240302161534635.png)

```js
//构造函数
function Person() {

        }
        Person.prototype.sing = function () {
            alert('唱歌')
        }
//实例对象
 const ldh = new Person()
       
        //此处Person是构造函数的身份
        console.log(Person.prototype.__proto__.constructor)//Object

 //此处Person是实例对象的身份，我觉得这个地方我不是很懂 但是不需要在意，因为我目前没有遇到过需要探讨这里的情况
        console.log(Person.__proto__.constructor) //Function

 console.log(ldh.__proto__ === Person.prototype) //true
//由于原型链的关系所以ldh.constructor === Person也为真，因为当ldh发现自己身上没有这个属性的时候，又因为ldh.__proto__ === Person.prototype，ldh就会通过__proto__向构造函数的prototype身上找，发现构造函数的prototype身上有这个属性 然后就可以使用了，所以我们可以通过constructor判断数据类型，但是由于constructor可以被修改，所以不推荐这个方法。
 console.log(ldh.__proto__.constructor === Person) //true,
console.log(Person.prototype.constructor === Person) //true,
 ldh.__proto__.sing()//此处也是ldh也是通过原型链在构造函数的原型对象上找到这个方法并使用的，直接写ldh.sing()也可以

```



#### 26.闭包

1、闭包的概念就是：有权利访问另一个函数作用域中的变量，一般就是函数包裹着函数。

3、闭包可以重用一个变量，且保证这个变量不会被污染的一种机制，就是避免全局污染。这些变量的值始终保持在内存中，不会被垃圾回收机制回收，也就是会造成内存泄漏

4、闭包的缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。

5、为什么要用闭包：使用场景 : 防抖、节流、函数套函数避免全局污染

闭包解决方法：在退出函数之前，将不使用的局部变量全部删除。

#### 27.call、apply、bind封装与区别

```js
//有一个疑惑 为什么下面算出来结果不一样，按照原型链来说应该是一样的才对吧 ，这个地方暂时放着，
console.log([1, 2, 3].__proto__.slice === [1, 2, 3].slice)//结果为true
        console.log([1, 2, 3].__proto__.slice(1, 3))//结果为空数组[]
        console.log([1, 2, 3].slice(1, 3))// 结果[2, 3]
```

相同点：都可以改变this的指向

call和apply的唯一区别由下可看出，只是传递参数的形式是不一样的，相同的代码求出的结果是完全一样的，并且函数会立即调用，

而bind只会改变this指向，而不会去调用函数，需要你自己去调用，看下面例子就明白了

```js
//可以看出 call和appy不同点：前者接收参数是一个序列，而后者必须是一个数组，但是实际上传递给函数的参数是数组内的变量，而不是这个数组
const obj1 = {
            uname: 'pink'
        }
        function fn(x, y) {
            console.log(this)//原本的是window
           console.log(this.uname)//如果不改变this指向，就不能通过this访问到obj1里面的uname
            console.log(x + y)//3
        }
        // call 改变this指向
        //call用法: 要改变this指向的函数.call(改变成谁,参数1,参数2) 其中参数只能是普通参数 不能是数组
        fn.call(obj1, 1, 2)
//这里是一个很新的用法，通过改变this指向来讲类数组对象转化为数组 下面结果相同
 console.log(Array.prototype.slice.call(arrayLike, 1, 3))
 console.log(Array.prototype.slice.apply(arrayLike, [1,3]))


   
```

```js
  const obj2 = {
            age: 18
        }

function fn(x, y) {
            console.log(this) //window
       console.log(obj2.uname)
            console.log(x + y) //3
        }
        // 1 调用函数
        // 2 改变this指向 
        // apply用法:要改变的函数.apply(改变成谁,[参数1,参数2,.....]) 其中传递参数必须为数组 改变成谁不能省略可以写null空，实际上使用的参数是数组里的属性，而不是这个数组
        fn.apply(obj, [1, 2])    
//巧妙用法求最大最小值 因为Math只能接收一个正常的如100, 44, 77这样的一个序列的参数，而不能接收一个数组
const arr = [100, 44, 77]
        const max = Math.max.apply(null, arr)
        
 //有个疑惑为什么这个式子new Array(1, 2, 3).__proto__.slice === new Array(1, 2, 3).slice相等，但是一旦带参结果就不一样了
        const arrayLike = {
            length: 3,
            0: 2,
            1: 3,
            2: 4,
        }
        //这里是一个很新的用法，通过改变this指向来讲类数组对象转化为数组
        console.log(Array.prototype.slice.call(arrayLike, 1, 3))
        console.log([1, 2, 3].slice(1, 3)) //这里用[1,2,3].__proto__.slice(1,3)结果为空 我就是不理解为什么
   let arr2 = [2, 3, 4]
        console.log(arr2.__proto__.constructor.prototype.__proto__ === Object.prototype)//true
```

```js
 //bind的使用
<button>点击</button>
    <script>
        const obj = {
            age: 18
        }
        function fn() {
            console.log(this)
        }
        // bind 改变this指向
        // 返回值是个函数 但是这个函数里面的this是更改过的obj
        const fun = fn.bind(obj)
        // console.log(fun)
        // fn.bind(obj)()
        fn()
        fun()

        // 需求 有一个按钮 点击里面就禁用 两秒之后恢复可以点击
        // 箭头函数不是万能的比如下面一行的function就不能用箭头函数 用了后面的this指向全部变成window了
        document.querySelector('button').addEventListener('click', function () {
            // 禁用按钮 此处this指向button
            this.disabled = true
            // 定时器这些函数其实前面都有一个window只不过一般都省略了
            window.setTimeout(function () {
                // 下面的代码可以不用bind直接箭头函数 这样这个this指向也是button
                // 还有一种方法 直接把下面的this改成button也可以
                // 由下面的bind所以现在这里的this指向不是window而是button
                this.disabled = false
                // 此处的bind(this)的this就是button 
            }.bind(this), 2000)
        })

      
```

#### 28.es6新特性（具体可以看csdn收藏的js八股文里，我笔记也有，vs直接搜就行	）

promise

新增了块级作用域(let,const)，利用let声明的变量和用const声明的常量无法跨块访问，块级作用域就是用大括号{}包裹的区域，函数作用域虽然也有一个{}，但是不算块级作用域。

新增了模板字符串

函数参数允许设置默认值，引入了 rest 参数（就是剩余参数），新增了箭头函数

新增了变量的解构赋值

对象在键值对一样的时候可以省略如{a：a}，可以写为{a}

对象和数组新增了...扩展运算符，可利用于浅拷贝

ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例，**Proxy** **对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。**以及新增了Reflect,而vue3的响应式原理就是**通过Proxy（代理）：** 拦截对象中任意属性的变化，包括：属性值的读写，属性的增加，属性的删除等。**通过Reflect（反射）：** 对源对象的属性进行操作而实现的。

提供了定义类的语法糖(class)

新增了一种基本数据类型(Symbol)

```js
// 它表示的是独一无二的值
    // 最大的用途：用来定义对象的私有变量
    // 如果用 Symbol 定义的是对象中的变量，取值时一定要用 [变量名] 
    // 如果用 Symbol 定义的是对象中的变量，该变量不能作为key，无法用 for 循环遍历
    // 注意： 这个数据类型实际开发中用的不多

    const name = Symbol('name')
    const name2 = Symbol('name')
    console.log(name === name2)          // false

    // 用来定义对象的私有变量
    let s1 = Symbol('s1')
    console.log(s1)
    let obj = {}
    obj[s1] = '牛肉粉'       // 等价于 obj = {  [s1]: '牛肉粉'   }    
    //如果用 Symbol 定义的是对象中的变量，取值时一定要用 [变量名] 
    console.log(obj[s1])
    console.log(obj.s1)     // 会报错

    //  如果用 Symbol 定义的是对象中的变量，该变量不能作为key，无法用 for 循环遍历
    for (let key in obj) {
        console.log(key)    // 没有输出
    }
    console.log(Object.keys(obj))    // 输出一个空数组 []

    // 想要输出symbol方法如下 两种方法可以
    console.log(Object.getOwnPropertySymbols(obj))
    console.log(Reflect.ownKeys(obj));
```

ES6 新增了 Set 和 Map 数据结构

```js
// set 就是一个类数组，不是数组，且类数组内的每一个值都独一无二，
//可以利用这个实现数组去重,首先讲数组new set(数组),然后用Array.from()方法讲set转化为真正的数组

    let set = new Set()
    // 添加元素 add()
    set.add(2)
    set.add('4')
    set.add('4')         // 这个4会被忽略，因为集合表示无重回复值的有序列表
    console.log(set)     // set(2) {2, "4"}
    // 也可以添加数组
    set.add(['hello', 'world', 3])

    // 删除元素 delete()
    set.delete(2)
    console.log(set)

    // 校验某个值是否在 set 中  has()
    console.log(set.has('4'))    // 返回 true

    // 访问集合的长度
    console.log(set.size)

    // set里面的foreach遍历 此处val和key输出是相同的 因为set结构的键名就是键值 也就是两个相同的意思 
    // 如果set里面没有数组就会foreach别的set里面的'4'
    set.forEach((val, key) => {
        console.log(val) //['hello', 'world', 3]
        console.log(key) //['hello', 'world', 3]
    })

    // set 转换成 数组
    let set2 = new Set([1, 2, 3, 3, 3, 4, 4])
    // 使用扩展运算符
    let arr = [...set2]
    console.log(arr) //[1, 2, 3, 4]

    // 1 set中的对象的引用无法被释放
    let set3 = new Set()
    obj = {}
    set3.add(obj)
    // 释放当前资源 应该就是删除的意思吧
    obj = null
    // 但是这个obj还存在于set中 说明set中的对象无法被释放 解决方法 WeakSet() 
    console.log(set3)

    // WeakSet()  成员只能是对象，其他都不行 2不可迭代 3没有foreach() 4没有size属性+
    let set4 = new WeakSet()
    obj2 = {}
    set4.add(obj2)
    obj2 = null
    console.log(set4);
```

```js
//Map类型是键值对的有序列表 键和值是任意类型,Map`对比`object`最大的好处就是，key不受`类型限制
        // 定义map
        const map1 = new Map()

        // 新增键值对 使用 set(key, value)
        map1.set(true, 1)

        // 判断map是否含有某个key 使用 has(key)
        console.log(map1.has('哈哈'))

        // 获取map中某个key对应的value
        console.log(map1.get(true))

        // 删除map中某个键值对 使用 delete(key)
        map1.delete('哈哈')


        // 定义map，也可传入键值对数组集合
        const map2 = new Map([[true, 1], [1, 2], ['哈哈', '嘻嘻嘻']])
        console.log(map2) // Map(3) { true => 1, 1 => 2, '哈哈' => '嘻嘻嘻' }
```

数组新增了一些 API，如 isArray / from / of 方法;数组实例新增了entries()，keys() 和 values() 等方法

对象新增了例如Object.assign（a，b）方法，可以合并对象，并让b覆盖掉a对象中相同属性名的属性，利用于浅拷贝

ES6 新增了生成器(Generator)和遍历器(Iterator)

ES6 模块化export和import

```js
//index.js
export const name = 'ggbond'
export function sayName() {
    return 66666
}
export class Person {
    constructor() {
    }
    say() {
        console.log('我是被抛出的构造函数')
    }
}
//默认暴露，每个文件只能使用一次
export default function obj() {
    return '默认输出 只能用一次'
}

//导入.html文件中引入
   // 在vscode必须用服务器打开  就是鼠标右键的open with live server打开
    // 这里的obj是用default 传出 不用括号包裹
    import obj, { name, sayName, Person } from './index.js'
    console.log(name, sayName(), obj())
    new Person().say() //构造函数里面的方法也可也调用
```

**迭代器**

```js
   // 遍历器（Iterator）它是一种接口，为各种不同的数据结构提供统一的访问机制，是一种新的遍历机制（对象不能迭代,而数组可以，因为数组内置iterator接口）
    // 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员），快捷的访问数据
    // 迭代和遍历的区别：迭代强调一次取数据的过程，不保证把所有数据取完，遍历强调把所有数据依次全部取出

    // 使用迭代
    const item = ['one', 'two', 'three']
    //item里面有这个函数 Symbol.iterator 就是迭代器函数 调用这个函数 就会返回一个迭代器  如下创建新的迭代器
    const ite = item[Symbol.iterator]()
    // 迭代器有一种方法next() 调用返回一个对象包括value和done两个属性 done为true的时候说明遍历结束，为什么我们要多next一次，因为只有多next一次才能看到遍历结束的标志 done：true，否则你也不知道遍历结束没
    console.log(ite.next())//{value: 'one', done: false}
    console.log(ite.next()) //{value: 'two', done: false}
    console.log(ite.next()) //{value: 'three', done: false}
    console.log(ite.next()) //{value: undefined, done: true}遍历结束
```

**生成器（Generator） **：

1.是 ES6 提供的一种异步编程解决方案，非常适合将异步任务同步化

2.Generator 是分段执行的,碰到 yield 就会暂停代码的指向，遇到next方法会继续启动代码执行。每次调用next()方法返回的是yield后的表达式结果，而next（20）小括号中的参数会作为当前yield的返回值，可以用变量接收到。

3.`Generator`函数会返回`Iterator`对象，因此我们还可以通过`for...of`进行遍历,原生对象没有遍历接口，通过`Generator`函数为它加上这个接口，就能使用`for...of`进行遍历了

4.async实质是Generator的语法糖，相当于会自动执行Generator函数

```js
  // 生成器函数:function关键字与函数名之间有一个星号 * ；函数体内部使用yield表达式，会中断后面的代码运行，只有执行next()才会恢复执行，直达碰到下一个yield又会停止，又要等下一个next()，而如果遇到return()就会直接在此处终止后方代码运行，当前生成的生成器对象的value为return传进的值，done变为true，哪怕后面还有next(),生成的对象的value都为undefined，done都为true
        function* add() {
            console.log('start')
    //next()传入的参数会作为上一个yield 的返回值  假如下一行的next(40) 所以上一个yield的返回值为20，所以               let x = yield '2' 的意思就是 x=40，而这里的这个'2' 是你yield生成的对象里的value值{value: '2', done: false}
            let x = yield '2'                 // yield 暂停执行标志 
            console.log('one:' + x)
            let y = yield '3'                 // yield 暂停执行标志
            console.log('two:' + y)
            return x + y
        }
        // 调用add函数返回一个遍历器对象 和对象调用Symbol.iterator方法相同 都是返回一个遍历器对象
        let fn = add()
        // next() 恢复执行标志
       // next()传入的参数会作为上一个yield 的返回值
        console.log(fn.next())  //    start    {value: '2', done: false}
        console.log(fn.next(20))    // one:20     {value: '3', done: false}
        console.log(fn.next(30))  //two:30  {value: '50', done: true}
//这里是第一个fn.next()的输出
 start
 {value: '2', done: false}
//这里是fn.next(20)的输出
 one:20
 {value: '3', done: false}
//这里是fn.next(30)的输出 因为此处没有yield，所以return的数据就作为生成器对象的value值
 two:30
 {value: 50, done: true}

//下面代码是修改了上面的
   function* add() {
            console.log('start')
            let x = yield '2'                 // yield 暂停执行标志
            console.log('one:' + x)
            let y = yield '3'                 // yield 暂停执行标志
            console.log('two:' + y)
        }
        let fn = add()
        console.log(fn.next())    
        console.log(fn.next(20))   
//注意 生成器的return()可以直接阻隔下方可能还存在的yield,done变为true，此处生成的对象的值就是你传入的参数  
        console.log(fn.return(30))  //{value: 30, done: true}

```

#### 29.静态成员和实例成员（js的构造函数在别的后台语言上叫做类）

1.实例成员就是构造函数内部通过this添加的成员 实例成员只能实例对象进行访问

2.静态成员是在 构造函数本身上添加的成员 静态成员只能通过构造函数访问 不能通过实例对象访问

```js
<script>
        function Star(uname, sex) {
            this.uname = uname;
            this.sex = sex;
            this.sing = function() {
                console.log("我会唱歌");
            }
        }
        var ldh = new Star("刘德华", "男");
        //1.实例成员就是构造函数内部通过this添加的成员 uname sex sing 就是实例成员
        //实例成员只能通过实例化对象来访问
        console.log(ldh.uname);//刘德华
        console.log(Star.uname); //不可以通过构造函数来访问实例成员 undefined
        //2.静态成员 在构造函数本身上添加的成员
        Star.age = '18'; //age 就是静态成员
        //静态成员只能通过构造函数来访问
        console.log(Star.age); //18
        console.log(ldh.age); //不能通过对象访问 undefined
    </script>

```

#### **30.MVVM和mvc框架**

1.**MVVM** 就是 Model-View-ViewModel 的缩写，MVVM 将视图和业务逻辑分开。

View：视图层，Model 数据模型，而 ViewModel 是把两者建立通信的桥梁。

在 MVVM 框架下，View 和 Model 之间没有直接的联系，而是通过 ViewModel 进行交互。View 和 ViewModel 之间以及 Model 和 ViewModel 之间的交互都是双向的，因此 view 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反映到 View 上。（可以说它们两者是实时更新的，互相影响。） ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，因此开发者只需要关注业务逻辑，不需要手动操作 DOM，也不需要关注数据状态的同步问题，这些都由 MVVM 统一管理。

优点：因为在MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可复用性。

缺点：由于双向绑定大量增加了内存开销，增加了程序的编译时间



2.**MVC** 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范

- Model（模型）：是应用程序中处理应用程序的数据逻辑的部分。通常模型对象负责在数据库中存取数据
- View（视图）：是应用程序中展示数据的部分。通常视图是依据模型数据创建的
- Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，并向模型发送数据,或者将Model的数据用View显示出来

**两者区别**：MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验，并且当数据发生改变的时候开发者还需要手动更新数据，而mvvm的数据更新是自动的。

![image-20240303171803716](assets/image-20240303171803716.png)

#### 31.图片懒加载是怎么实现的？

https://blog.csdn.net/darabiuz/article/details/123151266

首先我们将所有的图片设置一个相同的src，可以是一张相同，内存占用很小的图片，这样就只需要发一次请求，可以获取到所有图片当前的src地址，然后我们给每个图片<img>标签设置自定义属性 data-url （data-url可以换成data-任意），值为此图片真实的路径，然后我们计算出页面 scrollTop 的高度和浏览器的高度之和， 如果图片距离页面顶端的坐标 Y（相对于整个页面，而不是浏览 器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是其他情况），这时 候我们再利用dom.dataset.url获取到真正的url ，替换掉对应图片当前默认的地址就实现了图片懒加载

![image-20240304165614408](assets/image-20240304165614408.png)



```js
 <img src="./img/1.png" data-url="./img/1.png">
    <img src="./img/1.png" data-url="./img/2.png">
    <img src="./img/1.png" data-url="./img/3.png">
    <img src="./img/1.png" data-url="./img/4.png">
    <img src="./img/1.png" data-url="./img/5.png">


window.onload = function () {
         //获取到全部的img标签   下面两种方法都可以获取
        // let imgs = document.getElementsByTagName('img')
        var imgs = document.querySelectorAll("img");
        // 初始化执行
        lazyLoad(imgs);
        // 滚动执行
        window.addEventListener("scroll", function () {
          lazyLoad(imgs);
        });
 
        function lazyLoad(imgs) {
          for (let i = 0; i < imgs.length; i++) {
            var imgoffsetT = imgs[i].offsetTop; // 图片的距顶部的高度,这个顶部是浏览器顶部，不是可视区域顶部
            var wheight = window.innerHeight; // 浏览器可视区的高度
            var scrollT = document.documentElement.scrollTop; // 页面被卷去的高度
            if (imgoffsetT - scrollT <= wheight) {
              // 判断图片是否将要出现
                // 下面两种方法都可以
              // imgs[i].src = imgs[i].getAttribute('data-url'); //从dataurl中取出真实的图片地址赋值给url
              imgs[i].src = imgs[i].dataset.src; // 出现后将自定义地址转为真实地址
            }
          }
        }
      };


```

![image-20240304163939059](assets/image-20240304163939059.png)

####  32.for...in 迭代和 for...of 有什么区别

1、 推荐在循环对象属性的时候，使用 for...in,在遍历数组的时候的时候使用for...of。

2、 for in遍历的是数组的索引，而for of遍历的是数组元素值

3、for...of 不能循环普通的对象，而我们可以通过生成器让对象可以被for of使用

```js
var obj = {
    a:1,
    b:2,
    c:3
};

obj[Symbol.iterator] = function(){
	var keys = Object.keys(this);
	var count = 0;
	return {
		next(){
			if(count<keys.length){
				return {value: obj[keys[count++]],done:false};
			}else{
				return {value:undefined,done:true};
			}
		}
	}
};

for(var k of obj){
	console.log(k);//遍历结果是依次是后面三个数组 ['a', 1] ['b', 2] ['c', 3]
}

```

4、for...in 遍历顺序以数字为先 无法遍历 symbol 属性 可以遍历到公有中可枚举的

5、从遍历对象的角度来说，for···in会遍历出来的为对象的key，但for···of会直接报错。

#### 33.构造函数生成实例的执行过程：使用面向对象编程时,new关键字做了什么？

1.新建了一个Object对象

2.修改构造函数this的指向，使其指向新建的Object对象，并且执行构造函数

3.为Object对象添加了一个__proto__属性，是其指向构造函数的prototype属性

4.将这个Object对象返回出去

#### 34.构造函数和普通函数的区别

1.构造函数也是一个普通函数，创建方式和普通函数一样，但构造函数习惯上首字母大写;

2.构造函数和普通函数作用不一样，构造函数用来新建实例对象，普通函数调用是为了实现某些功能;

3.调用方式不一样,普通函数的调用方式：直接调用 person();构造函数的调用方式：需要使用new关键字来调用 new Person();

4.普通函数调用是没用返回值的，除非你在函数当中设定返回一个东西，构造函数调用有返回值，为创建的一个新的实例对象

5.构造函数的this指向对象，而普通函数的this则分几种情况

#### 35.构造函数和class类的区别

1.构造函数存在变量提升，构造函数可以调用可以在声明之前，而class在你声明之前调用就会产生暂存性死区（在代码块内，使用let和const命令声明变量之前，该变量都是不可用的，语法上被称为暂时性死区。）

2.构造函数可以不使用new，而类必须用，不然会报错![image-20240413115535548](assets/image-20240413115535548.png)

3.class原型上的对象不能遍历,当我们利用for in 去遍历构造函数实例对象的key键的时候，不仅this.的属性可以遍历出来，构造函数原型对象上的属性也可遍历出来，而class类只能遍历出constructor内的属性，而原型上的属性无法遍历

#### 35.rem和em的区别

1.em是相对长度单位，比px更具灵活性，em的长度是相对于父元素

2.rem的长度是相对于根元素，也就是html的字体大小

#### 36.常用的数组方法

forEach

map

indexOf  

splice  在指定元素前删除或新增数组元素,新增很好理解 splice(1,0,'ggbond'),意思就是添加一个字符串'ggbond'在数组下标为1的地方,且不删除任何元素

join

flat

from  将可迭代伪数组转化为真数组

reduce  累加

数组去重方法

every  全部被包含就为true

some 只要有一个就true

find  

filter

其中不影响原数组的方法有concat,filter,map,reduce,slice,join

#### 37.对象的继承方式

**1.原型链继承：将父类的实例作为子类的原型**

优点：父类方法可以复用

缺点：

1. 父类的所有引用数据类型如对象会被所有子类共享，当给A子类的引用属性增删改查的时候，B子类使用这个对象的时候也会同步，这里我明白为什么，还是引用的是数据的地址导致的,基本数据类型不存在这种影响。
2. 子类型实例不能给父类型构造函数传参

```js
function Parent() {
            this.isShow = true
            this.info = {
                name: "yhd",
                age: 18,
            }
        }

        Parent.prototype.getInfo = function () {
            console.log(this.info)
            console.log(this.isShow) // true
        }

        function Child() { };
        Child.prototype = new Parent()

        let Child1 = new Child()
        Child1.info.gender = "男"

        let child2 = new Child()
        child2.info.hobby = '篮球'
        Child1.getInfo()  // {name: "yhd", age: 18, gender: "男",hobby: '篮球'}
        child2.getInfo()  // {name: "yhd", age: 18, gender: "男",hobby: '篮球'}
        child2.isShow = false

        console.log(child2.isShow) // false
        console.log(Child1.isShow)//true
```

2.构造函数继承

原理：由于构造函数的this指向他的实例对象，所以当他的实例对象调用构造函数的某个this.属性的时候可以拿到；我们就利用call或apply将构造函数A的this指向另外一个B构造函数的实例对象，那么那个实例对象也就能通过this访问到构造函数A的属性了

优点：解决了原型链继承不能传参和子实例对象之间引用数据类型数据关联的问题，之所以能解决引用数据类型的问题，因为构造函数的this指向实例对象，而子类的两个实例对象this肯定就是不同的啊。

缺点：在父类型的原型中定义的方法，子类型是访问不到的，方法都只能在构造函数中定义，因此无法原型链上函数在不同子类型上复用。

```js
function Parent(name) {
    this.info = { name: name };
}
function Child(name) {
    //继承自Parent，并传参
    Parent.call(this, name);
    
     //实例属性
    this.age = 18
}
Parent.prototype.fun = function () {
            console.log(111111)
        }

let child1 = new Child("yhd");
console.log(child1.info); // {name: 'yhd'}


let child2 = new Child("wxb");
console.log(child2.info); // {name: 'wxb'}


```

3.组合继承

将 `原型链` 和 `借用构造函数` 的组合到一块。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性，而不是共享引用数据类型如obj

缺点：无论在什么情况下，都会调用两次父类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部

```js
function Person(gender) {
  console.log('执行次数');
  this.info = {
    name: "mjy",
    age: 19,
    gender: gender
  }
}
 
Person.prototype.getInfo = function () {   // 使用原型链继承原型上的属性和方法
  console.log(this.info.name, this.info.age)
}
 
function Child(gender) {
  Person.call(this, gender) // 使用构造函数法传递参数
}
 
Child.prototype = new Person()
 
let child1 = new Child('男');
child1.info.nickname = 'xiaoma'
child1.getInfo()
console.log(child1.info);//{name: 'mjy', age: 19, gender: '男', nickname: 'xiaoma'}
 
let child2 = new Child('女');
console.log(child2.info);//{name: 'mjy', age: 19, gender: '女'}
```

4.原型式继承

看代码就能明白 ，在一个函数A内部创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后return 返回这个构造函数的一个实例对象。

优点：不需要再创建子构造函数

缺点：引用数据类型会在多个子类型之间共享

```js
//方法1

function createObject(obj) {
  function Fun() {}
  Fun.prototype = obj
  return new Fun()
}
 
let person = {
  name: 'mjy',
  age: 18,
  hoby: ['唱', '跳'],
  showName() {
    console.log('my name is:', this.name)
  }
}
 
let child1 = createObject(person)
child1.name = 'xxxy'
child1.hoby.push('rap')
let child2 = createObject(person)
 
console.log(child1)
console.log(child2)
console.log(person.hoby) // ['唱', '跳', 'rap']

//方法2，Object.create()，本质就是将上面的函数封装到了这个方法里面，在只有一个参数时，Object.create()与上方的函数方法效果相同。

let child1 = Object.create(person)//和上面的let child1 = createObject(person)是一样的
```

5.寄生类继承

优点：也是不需要给子类型创建构造函数

缺点：父原型对象上的对象在多个子类型上是共享的，在对象上定义的函数无法复用(这一点有点不是很明白)

```js
  function objectCopy(obj) {
            function Fun() { };
            Fun.prototype = obj
            return new Fun()
        }

        function createAnother(obj) {
            let clone = objectCopy(obj)
            //这里相当于给实例对象身上添加一个属性，属性值为一个函数，所以这个函数的this当然指向的就是调用它的这个对象
            clone.showName = function () {
                console.log('my name is：', this)
            }
            return clone
        }

        let person = {
            name: "mjy",
            age: 18,
            hoby: ['唱', '跳']
        }

        let child1 = createAnother(person) //child1就是一个实例对象，也就是对象，在child1身上添加的属性，当然就是对象的属性，也可以说是实例成员
        console.log(child1)
        child1.a = 1 //直接给child1这个对象添加一个属性a，值为1
        console.log(child1.__proto__.age = 19) //这里我理解错了，当直接给child1.age=19，那么是给child1这个对象身上添加了一个age属性值为19，而不是拿到他原型对象上的age去修改值
        child1.hoby.push("rap") //这里是给child1的对象原型上的hoby数组添加了属性，所以下方的child2也会共享到
        child1.showName()
        let child2 = createAnother(person)
        child2.showName()
```

6.寄生组合式继承：这种直接不看了，代码太复杂了，目前我看不懂

7.es6的Class继承（顺带讲一下class）

![image-20240323180442641](assets/image-20240323180442641.png)

https://blog.csdn.net/weixin_44784401/article/details/128903221   没有讲到super这些，

写在constructor{}外的方法，在class中默认会当成是这个class类的原型对象上的方法

类的所有实例共享一个原型对象，说白了就是构造函数继承

class本质上就是构造函数的语法糖

```js
// 由下面的例子，看p0和p1就知道了，其实这两个生成的数据是一摸一样的，不会因为一个是对象赋值，一个是实例对象生成而有什么不同，所以可以得出结论，构造函数在class中就是简化了我们给对象赋值的过程，减少了代码量而已。

//且注意，preson和Person2这两种写法利用new生成的实例对象一摸一样，原姓对象上的方法也一摸一样

class Person{
 // 每new一个对象后都会执行这个函数
  constructor(name, age, gender){
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
    //写在constructor之外的方法会被当作这个class类的原型对象上的方法
     toString() {
     return '(' + this.x + ', ' + this.y + ')';
   }
}
function Person2(name, age, gender){
 // 每new一个对象后都会执行这个函数
    this.name = name;
    this.age = age;
    this.gender = gender;
}
Person2.prototype.toString = function () {
   return '(' + this.x + ', ' + this.y + ')';
 };


// 不使用构造函数
let p0 = new Person();
p0.name= '李四';
p0.age= 19;
p0.gender= '男';
console.log(p0); // object

// 使用构造函数
let p1 = new Person('李四', 19, '男');
console.log(p1); // object


```

#### 38.scoped和/deep/穿透；或::v-deep

![image-20240317153743131](assets/image-20240317153743131.png)

#### 39.js的几种模块规范

![image-20240319215155843](assets/image-20240319215155843.png)



#### 40.预处理器less和sass

css预处理器是用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。

**sass和less**

Sass是一种基于Ruby的CSS预处理器，它可以扩展CSS语言，并添加许多其他功能，如变量、嵌套规则、Mixin、函数等。Sass文件以“.scss”扩展名保存，使用缩进的语法代替css的大括号和分号；并不是特别被开发者接受；而Scss其实就是sass3引入的一种语法格式，对以前的sass进行改进，和css的规范一样使用花括号和分号进行分隔，所以scss更常用。

**less**

Less是一种基于JavaScript的CSS预处理器，它与Sass和Scss有很多相似之处，但它使用类似CSS的语法，比sass更容易学习和使用。Less支持变量、Mixin、嵌套规则等功能，并且可以在客户端和服务器端使用，且编译速度比sass更快

1.使用变量：

```js
//Less定义变量： 
@color: #4D926F;
 
header {
color: @color;
}
 
//Sass定义变量
$blue : #1875e7;　
 
div {
　color : $blue;
}
// 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。下面就是设置左边框圆角
$side : left;
.rounded {
　　border-#{$side}-radius: 5px;
}
```

2.混合(Mixins)：Less中使用混合时类似于函数用法，只需在classB中根据classA的命名来使用；Sass中首先在定义混合时需要使用@mixin命令，其次在调用时需要使用@include命令来引入之前定义的混合。

```js
//Less中的混合： @radius: 5px为你设定的默认值，你不传参就使用默认值，可以不使用括号调用，但是为了更好区分，所以一般加上调用.corners()；记住混入可以不带参数，那么定义混入就是.corners{}  在别的地方使用就如header标签  header{.corners}即可
.corners (@radius: 5px) 
{     
    -webkit-border-radius: @radius; 
    -moz-border-radius: @radius; 
    -ms-border-radius: @radius; 
    -o-border-radius: @radius; 
    border-radius: @radius; 
}
 
header {
.corners();//.corners；也可以，只是不容易辨别出来使混入
}
 
footer {
    //这里的10px相当于使传参
.corners(10px);
}
 
//Sass中的混合：    如果不传默认参数，就可以不写()直接写成@mixin left   调用就最直接　@include left
@mixin left($value: 10px) { 　　　　
    float: left; 　　　　
    margin-right: $value; 　　
}
 
div {
　　　　@include left(20px);
　　}
 

```

3.嵌套：

class中嵌套class，从而减少代码的重复。

```js
// 在嵌套的代码块内，可以使用&引用父元素。less和sass都是用&,比如a:hover伪类，可以写成
a {
　　&:hover { color: #ffb3ff; }
}
```

4.运算：

提供了加减乘除四则运算，可以做属性值可颜色的运算。

```js
//这里是less进行四则运算，sass就是将@换成$即可
@margin: 10px;

.button {
  margin: @margin * 2;
    top: 50px + 100px
}

```

5.继承：如果b选择器需要继承a选择器

```js
.a {
　　border: 1px solid #ddd;
}
.b {
　　@extend .class1;
　　font-size:120%;
}
```

6.sass还可以使用if 或if...else或for循环，while循环，each循环；这些是less没有的

7.引入，假如有一个sass文件名为 aaa.scss  我们就可以利用@improt "aaa.scss"引入，less也是同样引入方式，然后就可以在当前的html文件下使用别的sass或less中定义的如变量或者混入。

#### 41.对ts的泛型和接口的了解（ts都忘光了）



#### 42.有哪些设计模式（面试问到且没回答出来，还要记住实际的例子）

https://blog.csdn.net/weixin_43786756/article/details/122816094

1.单例模式：一个类只有一个实例，并提供一个访问他的全局访问点。我打个比方，普通的类声明两个实例对象，那么这两个实例对象是独立的，互相不影响的，单例模式就是让你不同的实例对象调用类的时候，属性和方法是互相关联的，比方实例对象a利用构造函数上某个方法让构造函数上的某个属性加1，b也相同的操作，那么不使用单例模式这个属性的值是独立的，分别在a和b上都为1；使用了单例模式，我们进行加操作的是同一个属性，所以后进行加1操作的b拿到的这个属性值为2.

```js
//所有的实例操作的都是同一个实例的方法或属性，因为单例模式时调用类生成实例对象生成的是同一个实例，只不过是用不同变量接收了而已
class Logger {
  constructor() {
      //如果还没有创建过实例对象就创建
    if (!Logger.instance) {
      this.logs = [];
      Logger.instance = this;// Logger.instance = new logger();这种写法是一样的，因为this指向的就是类的实例对象
    }
// 如果这个唯一的实例已经存在，则直接返回，不给类创造其他实例的机会
    return Logger.instance;
  }

  log(message) {
    this.logs.push(message);
    console.log(`Logger: ${message}`);
  }

  printLogCount() {
    console.log(`Number of logs: ${this.logs.length}`);
  }
}

// 可以使用全局变量来访问实例
const logger = new Logger();
Object.freeze(logger);

// 对于每个实例，输出应该是相同的
logger.log('First message'); // Output: Logger: First message
logger.printLogCount(); // Output: Number of logs: 1

const anotherLogger = new Logger(); // 此时返回一个已经存在的实例
anotherLogger.log('Second message'); // Output: Logger: Second message
anotherLogger.printLogCount(); // Output: Number of logs: 2

```

**例子**：

比如vuex实现了一个全局的store用来存储应用的所有状态，并且不同组件操作的是同一个store中的state，store就是典型的单例模式，通过调用`Vue.use`方法，[安装Vuex](https://so.csdn.net/so/search?q=安装Vuex&spm=1001.2101.3001.7020)插件。Vuex插件本质上是一个对象，内部实现了一个`install`方法，这个方法在插件安装时被调用，从而把`Store`注入到`Vue`实例中，这个方法会进行判断，如果你这个vue实例已经install了一次vuex插件，就会return 返回出去，只有你没用install的时候才会install，使得一个vue实例只install一个vuex，每个 Vue 实例只会共享一个全局的 Store仓库。



2.工厂模式：根据传入的不同的参数，返回不同类的实例。通俗讲就是通过你实例化构造函数时传入不同的参数，返回一个不同的实例对象，很好理解，如下

```js
// 定义一个抽象类
class Animal {
  speak() {
    throw new Error('This method must be implemented.');
  }
}

// 实现具体的类
class Dog extends Animal {
  speak() {
    return 'Woof!';
  }
}

class Cat extends Animal {
  speak() {
    return 'Meow!';
  }
}

// 实现工厂方法
class AnimalFactory {
  createAnimal(animalType) {
      switch(animalType) {
        case 'dog':
          return new Dog();
        case 'cat':
          return new Cat();
        default:
          throw new Error(`Invalid animal type: ${animalType}`);
      }
  }
}

// 使用工厂方法创建对象
const animalFactory = new AnimalFactory();
const dog = animalFactory.createAnimal('dog');
console.log(dog.speak()); // Output: Woof!
const cat = animalFactory.createAnimal('cat');
console.log(cat.speak()); // Output: Meow!


```

**实际例子：**

1.`document.createElement` 创建 `DOM` 元素。这个方法采用的就是工厂模式，方法内部很复杂，但外部使用很简单。只需要传递标签名，这个方法就会返回对应的 `DOM` 元素。

2.`Vue` 和 `React` 这种具有虚拟 `DOM` 树机制的框架在生成虚拟 `DOM` 的时候，都提供了 `createElement` 方法用来生成 `VNode`，用来作为真实 DOM 节点的映射。上面实现一致，调用`createElement`后，返回`VNode`元素。

```js
// 在vue中创建一个带有子标签的虚拟dom
ccreateElement('h3', { class: 'main-title' }, [
    createElement('p', { class: 'main-content' }, '真有意思')
])

// 函数大致结构如下
export function createElement(tag,data,children){
    //....各种判断 判断生成什么样的Vnode
    if(!tag){
        return createEmptyVNode()
    }
    return new VNode(tag,data,children);
}

```



3.策略模式：定义一系列算法，根据输入的参数决定使用哪个算法。为什么要提出这个模式，因为如果我要做例如表单验证，如我想要必须是掘金用户，且等级必须大于1，如果还有其他很多条件，我们全部用v-if确实可以做到，但是就违反了**开闭原则**。并且注意判断条件的函数可以有很多个，不同的时候我们可以调用其中某一些方法来判断，不需要全部，如用户a要判断年龄和性别，满足则通过，用户b不判断年龄，判断性别和升高，全部满足则通过，所有我们可以定义很多判断函数，只取其中一些来使用，这就是策略模式。比如饿了么ui的表单验证，就是用策略模式实现的。

```js
// 维护权限列表
const jobList = ['前端', '后端'];
// 策略，里面的方法都是进行判断，满足返回true，不满足返回false
var strategies = {
  checkRole: function(value) {
    return value === 'juejin';
  },
  checkGrade: function(value) {
    return value >= 1;
  },
  checkJob: function(value) {
    return jobList.indexOf(value) > 1;
  },
  checkEatType: function(value) {
    return value === 'eat melons';
  }
};


// 校验规则的构造函数
  function Validator() {
  this.cache = [];
  // 添加策略事件，这里就是将所有需要判断的条件放入到指定的判断方法中并以数组元素形式放在一起，方便下面检查的时候遍历
  this.add = function(value, method) {
      //此处添加了判断方法，但是注意还没调用啊
    this.cache.push(function() {
      return strategies[method](value);
    });
  };
  // 检查，遍历所有需要进行校验的函数，全部函数判断为true，那么校验成功，有一个校验错误返回false，就校验失败，不满足
  this.check = function() {
    for (let i = 0; i < this.cache.length; i++) {
      let valiFn = this.cache[i];
      var data = valiFn(); // 开始检查
      if (!data) {
        return false;
      }
    }
    return true;
  };
};


// 使用策略模式进行判断是否满足  条件为角色:掘金用户,等级：3，全部满足才可以通过校验
var compose1 = function() {
  var validator = new Validator();
  const data1 = {
    role: 'juejin',
    grade: 3
  };
    //将需要判断的属性放到对应的方法中，并返回这个还没有调用的方法
  validator.add(data1.role, 'checkRole');
  validator.add(data1.grade, 'checkGrade');
    //利用循环的方式调用每一个判断函数，只要有一个不满足就返回false，校验失败
  const result = validator.check();
  return result;
};
 console.log(compose1()) //true 说明判断成功

// 阿宽使用策略模式进行操作 条件和上面的不一样 角色：juejin  工作:前端
var compose2 = function() {
  var validator = new Validator();
  const data2 = {
    role: 'juejin',
    job: '前端'
  };
  validator.add(data2.role, 'checkRole');
  validator.add(data2.job, 'checkJob');
  const result = validator.check();
  return result;
};
 console.log(compose2()) //true 说明判断成功


```

4.发布-订阅者模式（不是很明白）



5.适配器模式：用于解决兼容问题，接口/方法/数据不兼容，将其转换成访问者期望的格式进行使用。比如我们的手机需要插口为type-c，但是我们的耳机为圆孔，那么此时的type-c的转接头就是我们的适配器，这种模式很好理解。看例子

```js
//我们要获取通过多个接口获取列表数据，拼接在一起，在一个组件内进行展示。因历史遗留原因，这些列表数据的属性名相似，且相似属性名代表的值是同一种，比如分别都是一个人的姓名，只不过一个的属性名为name1，另一个为name2，我们想将其整合在一起,如下
// 数据1
{
    book_id: 1001
    status: 0,
    create: '2021-12-12 08:10:20',
    update: '2022-01-15 09:00:00',
},
//数据2
{
    id: 1002
    status: 0,
    createTime: 16782738393022,
    updateAt: '2022-01-15 09:00:00',
},
//这两种格式我们想要使用一种统一的格式来兼容，因为其实他们代表的东西是一样的，只是不同开发者取名有些许区别，我们可以定义统一的数据结构
    interface bookData {
  book_id: number;
  status: number;
  createAt: string; // 时间戳
  updateAt: string; // 时间戳
}

//定义上面两种格式对应的接口
interface bookDataType1 {
  book_id: number;
  status: number;
  create: string;
  update: string;
}

interface bookDataType2 {
  id: number;
  status: number;
  createTime: number;
  updateAt: string;
}
//转换成时间戳的方法
const getTimeStamp = function (str: string): number {
  //.....转化成时间戳
  return timeStamp;
};

//适配器    
export const bookDataAdapter = {
    //数组属性全部为bookDataType1这种对象类型
  adapterType1(list: bookDataType1[]) {
    //利用map方法，将不统一的值一一赋值给对应的属性，很好理解
    const bookDataList: bookData[] = list.map((item) => {
      return {
        book_id: item.book_id,
        status: item.status,
        createAt: getTimeStamp(item.create),
        updateAt: getTimeStamp(item.update),
      };
    });
    return bookDataList;
  },
//数组属性全部为bookDataType2这种对象类型
  adapterType2(list: bookDataType2[]) {
    const bookDataList: bookData[] = list.map((item) => {
      return {
        book_id: item.id,
        status: item.status,
        createAt: item.createTime,
        updateAt: getTimeStamp(item.updateAt),
      };
    });
    return bookDataList;
  },

//最后将所有数据经过适配器处理后放在一起
      const bookDataList = [
  ...bookDataAdapter.adapterType1(type1MatailList),
  ...bookDataAdapter.adapterType2(type2MatailList),
];


```



#### 43.移动端和pc端开发的一些区别

1. PC需要考虑浏览器的兼容性，ie6-11，firefox，chrome，safari等各种浏览器内核可能在js或css存在一些兼容问题（比如css样式，兼容谷歌就是在这个css前加修饰-webkit-），而移动端开发考虑的更多的是手机兼容性，因为目前不管是android手机还是ios手机，一般浏览器使用的都是webkit内核，所以说做移动端开发，很少需要考虑浏览器的兼容问题，比如动画，是css3提出的，所以如果要兼容ie浏览器的时候，有时候就需要尽量用js利用定时器实现动画的效果，而移动端就不存在这个问题，可以直接使用动画
2. 移动端需要考虑分辨率的适配问题，手机的屏幕尺寸存在很多不同型号，一般采用媒体查询（直接写在style里面就行，转换成rem利用vs当中的插件就可以很好实现）或流式布局（宽度利用百分比来实实现在不同屏幕自适应，高度固定）来解决。
3. 操作方式不同，所以我们需要使用的监听事件有所不同，比如pc端主要就是鼠标移入移出，鼠标左键右键点击，键盘事件等，而键盘事件在移动端的兼容性不好，因为在手机端我们使用的是虚拟键盘，所以一般利用input事件来监听用户的输入；PC的操作大部分基于鼠标，所以事件类型以“mousexxx”为主；但是移动端的操作以手指为主，所以mouse系列事件在移动端兼容性都不好；移动端就是用的比如单击，双击（双击是有个判断，如果单击后在300ms内再次点击则判断为双击事件），长按，滑动等。

 

#### 44.物理像素这类东西（我前端学习文件夹的移动端流式布局内有一些例子）

#### 45.包含块（看渡一大师课文件夹的02里面有）

#### 46.使用js实现动画

这里我有个两个疑惑，首先是我尝试用transform好像实现不了这个效果，还有如果不用++而用模板字符串实现，写法我还不清楚

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    div{
        background-color: red;
        height: 300px;
        width: 300px;
        position: absolute;
    }
</style>
<body>
<button >点击移动五百米</button>
    <button class="btn2">点击移动八百米</button>
<button class="btn3">回到原点</button>
<div></div>
    <script>
// 简单动画函数封装
// function animate(obj, rug) {
//     var timer = setInterval(function () {
//         if (obj.offsetLeft >= rug) {
//             clearInterval(timer);
//         }
//         obj.style.left = obj.offsetLeft + 2 + 'px';
//     }, 30)
// }
// const div = document.querySelector('div');
// animate(div,300);

function animate(obj, rug,fun) {
      //这相当于是调用一个函数
   if(fun){
       fun()
   }
    clearInterval(obj.timer);
    obj.timer = setInterval(function () {
        // 步长值，相当于是调用十次定时器移动到指定位置并清除定时器
        var step = (rug - obj.offsetLeft) / 10;
        if (obj.offsetLeft == rug) {

            clearInterval(obj.timer);
        } else {
            obj.style.left = obj.offsetLeft + step + 'px';
        }
    }, 20)
}
var div = document.querySelector('div');
var but = document.querySelector('button');
but.addEventListener('click', function () {
    //此处我们传入函数，回调函数原理:函数可以作为一个参数。将这个函数作为
    // 参数传到另一个函数里面 ,当那个函数执行完之后,再执行传进去的这个函数,这个过程就叫做回调。
    animate(div, 500,function (){alert('hello')});
})
        //移动到相对div右侧800px
        const btn2=document.querySelector('.btn2')
btn2.addEventListener('click',function (){
    animate(div, 800, ()=>{alert('hello')});
})
//回到原点
const btn3=document.querySelector('.btn3')
btn3.addEventListener('click',function (){
    animate(div, 0, ()=>{alert('hello')});
})
    </script>
</body>

</html>
```

#### 47.可以继承的css属性（没写出来的都是不能继承的）

![image-20240412171925044](assets/image-20240412171925044.png)

#### 48.herf和src的区别

这里有讲到关于css和js代码在渲染的时候是否被阻塞，可以看看https://blog.csdn.net/qq_38951259/article/details/131557636

当HTML解析器解析HTML，如果遇到`script`标签，普通的`script`标签会暂停对DOM解析渲染，因为该脚本可能会修改DOM，`link`标签并不阻塞DOM的解析，但会阻塞DOM的渲染。浏览器并行解析生成DOM Tree 和 CSSOM Tree，当两者都解析完毕，才会生成render tree，页面才会渲染。所以应尽量减小引入样式文件的大小，提高首屏展示速度。JS运行时，有可能会请求样式信息，如果此时还没有加载和解析样式，js就有可能会得到错误的回复，产生很多问题。因此浏览器在`link`标签的加载和解析过程中，会禁止脚本运行。

**（1）请求资源类型不同：**

href是超文本引用的简写，用来为当前元素和文档之间建立连接，常用的是link（在引入外部css的时候用到这个标签）、a标签。
src会将指向的资源下载并引用到当前文档中，常用的标签有script，img，[iframe](https://so.csdn.net/so/search?q=iframe&spm=1001.2101.3001.7020)标签，readio，viedo。

**（2）作用的结果不同：**

href是为当前文档和引用资源建立联系；而src是替换当前的元素。

```js
//如下是test.js
console.log(2)

//下面是另外一个html文件，并且引入了上面的test.js这个文件，那么这个html文件输出打印的是2，因为script标签的src会将引入的文件替换掉你原本script标签内的内容
<script src="./test.js">
    console.log(1)
</script>
```

（**3）浏览器的解析方式不同（这里涉及到了html的渲染过程，css代码不会被阻塞，而js代码会被阻塞）**

herf引用的资源，浏览器会将其识别为CSS文档，并行下载资源并且不会停止对当前文档的处理。
当浏览器解析到src时，会暂停其他资源的下载和处理，直接将该资源下载，编译，执行完毕，图片和框架也是如此，类似于将所指资源应用到当前内容

#### 49.link和@import的区别

结论：建议用link，慎用@imoport。本质上，这两种方式都是为了加载css文件，但还是存在细微的差别。

link详细:https://blog.csdn.net/Don_GW/article/details/109380508

区别：

1.引入方式不同：@import是CSS的语法规则，只能用来导入[样式表](https://so.csdn.net/so/search?q=样式表&spm=1001.2101.3001.7020)。而link是HTML的一个标签，可以引入CSS样式，还可以通过rel规定样式表的属性（rel="stylesheet"，rel属性表示的是当前文档与被引入文档之间的关系，stylesheet意思样式表）

2.加载顺序不同：`link`标签让浏览器知道这是个样式表文件，html的解析和渲染不会暂停，css文件的加载是同时进行的，；`@import`添加的样式是在页面加载完之后才会被加载。 ，这可能会导致页面因重新渲染而闪烁。

3、兼容性区别

@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。

4、DOM可控性区别

可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。

```html
 <head>
    <!-- link是标签，引入外部样式表 -->
    <link rel="stylesheet" href="./a.css">
    <style>
        /* @import 在css环境中 导入外部css */
        @import url('./b.css');
        .box{
          width: 100px;
          height: 100px;
          background: green;
        }
    </style>
</head>

```

#### 50.Javascript中callee和caller的作用和区别

caller 是返回⼀个对函数的引⽤，该函数调⽤了当前函数；

callee 是返回正在被执⾏的 function 函数，也就是所指定的 function 对象的正⽂，它是 arguments（动态参数） 的⼀个属性

**区别**

caller：这个属性只有当函数在执⾏时才有⽤

如果在 javascript 程序中，函数是由顶层调⽤的，则返回 null

functionName.caller: functionName 是当前正在执⾏的函数。

function a() {

 console.log(a.caller)

}

callee：这个属性只有在函数执⾏时才有效

它有⼀个 length 属性，可以⽤来获得形参的个数，因此可以⽤来⽐较形参和实参个数是

否⼀致，即⽐较 arguments.length 是否等于 arguments.callee.length

它可以⽤来递归匿名函数

function a() {

 console.log(arguments.callee)

}

#### 51.window.onload

window.onload() ⽅法是必须等到⻚⾯内包括图⽚的所有元素加载完毕后才能执⾏

#### 52.单向数据流

[单向数据流](https://so.csdn.net/so/search?q=单向数据流&spm=1001.2101.3001.7020)是一种数据流动的模式，通常用于前端框架（如 React、Vue ，vuex仓库）中。在单向数据流中，数据只能从一个方向流向另一个方向，不会出现数据的双向流动。这种模式有助于简化数据的管理和状态的维护，提高代码的可维护性和可预测性。在单向数据流的模式中，数据通常是从父组件流向子组件，子组件可以接收父组件传递的数据进行渲染。子组件可以通过回调函数将事件传递给父组件，父组件再更新数据并重新渲染子组件，形成数据的单向流动，这种回调函数的方式我觉得自定义事件就是这种方式实现子传父

**单向数据流的特点包括：**

数据流动的方向是单向的，通常是从父组件到子组件。
数据的修改通常是通过事件或回调函数来触发，父组件维护数据状态并传递给子组件。
子组件不直接修改父组件的数据，而是通过回调函数将事件传递给父组件，由父组件来处理数据的更新。

**单向数据流的优点包括：**

简化数据流动的逻辑，降低了数据的复杂性。
提高了数据的可预测性和可维护性，方便进行状态管理和调试。
降低了组件之间的耦合度，提高了代码的灵活性和可重用性。



#### 53.window.open和location.href的区别

前者是打开一个新的窗口，后者属于是一直在一个窗口切换页面，这只是一部分区别

https://blog.csdn.net/weixin_46163658/article/details/121764673

#### 54.script标签中得async和defer属性

注意：async和defer属性只适用于利用src引入外部脚本，纯script标签不受async和defer影响，写了也没用

**1.纯script标签，没用async和defer属性**

当浏览器加载 HTML 并遇到`<script>...</script>`标签时，它无法继续构建 DOM，停止解析。并立即执行脚本。外部脚本`<script src="..."></script>`也是如此：浏览器必须等待脚本下载（就是发送网络请求获取到该js脚本得代码内容），执行下载下来得脚本的代码，当脚本代码执行完毕，然后才能恢复html的解析，处理页面的剩余部分的内容。

存在的问题：script 阻塞了浏览器对 HTML 的解析，如果获取 JS 脚本的网络请求迟迟得不到响应，或者 JS 脚本执行时间过长（就是脚本内容过大），都会导致白屏，用户看不到页面内容。、

有一个解决办法：将脚本放在整个html文件最底部，但是还是存在问题，如果html文件很大，那么会存在明显延迟

```js
<p>...content before script...</p>
//当执行到这里会阻塞浏览器解析html内容，直到脚本中js代码执行完毕才会执行script下方的内容
<script src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<!-- 以下在脚本加载完之前是不可见的 -->
<p>...content after script...</p>

```

如图

![image-20240420124546360](assets/image-20240420124546360.png)

这是script标签中没有async和defer的情况，遇到script停止html解析，下载js脚本代码，然后执行脚本代码，然后恢复html解析

![image-20240420124602943](assets/image-20240420124602943.png)



**2.存在defer属性**：当浏览器遇到带有 defer 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是等待 HTML 解析完毕，也就是dom完全构建后再执行 JS 代码。

```js
<p>...content before script...</p>

<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<!-- 不等待脚本,立即显示 -->
<p>...content after script...</p>

```

存在defer属性时，在html解析的过程中下载script标签中的js脚本，并在html解析完毕后执行下载完成的js脚本代码。

![image-20240420124858164](assets/image-20240420124858164.png)

**3.存在async属性**：当浏览器遇到带有 async 属性的 script 时，请求该脚本的网络请求是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器会暂停解析，先让 JS 引擎执行代码，执行完毕后再进行解析

![image-20240420125251979](assets/image-20240420125251979.png)

**4.可以动态加载script脚本**，默认是以async方式加载，如果将async置为false，就是defer方式动态加载

```js
function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  script.async = false;
  document.body.append(script);
}

// long.js runs first because of async=false
loadScript("/article/script-async-defer/long.js");
loadScript("/article/script-async-defer/small.js");

```

#### 55.document.domain实现跨子域

**注意,默认情况下子域访问主域http://example.com访问http://www.example.com或者反过来主域访问子域都属于跨域;而相同主域的子域之间不属于跨域,如a.baidu.com和b.baiodu.com,如果他们的主域都设置为baidu.com,那么他们访问时候就不存在跨域.**

默认情况下，document.domain存放的是载入文档的服务器的主机名，可以手动设置这个属性，设置该属性有两个特点：

1.只能设置成当前域名，或者当前域的二级域名（比如document.domain为 www.baidu.com，可以设置成 baidu.com）

2.任何对document.domain的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null(利用这个特点我们就可以实现端口号不同但document.domain相同的跨域)

**3.相同二级域名之间的跨域**:例如`http://www.qq.com`的document.domain为"qq.com"，`http://id.qq.com`的document.domain为"id.qq.com"，默认情况下，id.qq.com是无法对www.qq.com进行跨域操作的,注意,此时www.qq.com是可以实现对id.qq.com此时但是，如果通过将document.domain设置成"qq.com"就可以实现跨域了,在html文件的script标签中写入即可,

**4.相同域名，不同端口之间的跨域**:`http://http://localhost:3001/window.html`的document.domain为"localhost"，`http://localhost:3002/b.html`的document.domain也为"localhost"，但是他们的端口一个是3001，一个是3002，此时window.html和b.html是存在跨域的,我们只需要把两者的document.domain='localhost',此时端口号就被重写为null,即可实现跨域.

#### 56.背景渐变色

```css
//从上到下
background-image: linear-gradient(to bottom, #ff9966, #ff5e62);
//也可以这样 在0% 50% 100%的时候变
background-image: linear-gradient(to right, #ff9966 0%, #ff5e62 50%, #ffcc00 100%);

```

#### 57.鼠标拖拽效果实现

```js
<script type="text/javascript">
		let btnEle = document.getElementById("help-btn");
 
		//帮助按钮鼠标按下时
		btnEle.onmousedown = (e) => {
			let defaultX = e.clientX; //默认位置的x轴坐标
			let defaultY = e.clientY; //默认位置的y轴坐标
 
			let defaultLeft = btnEle.offsetLeft; //默认左侧偏移位置
			let defaultTop = btnEle.offsetTop; //默认顶部偏移位置
 
			//帮助按钮鼠标移动时
			btnEle.onmousemove = (me) => {
				btnEle.style.cursor = "move"; //修改鼠标样式
 
				let nowX = me.clientX; //当前位置的x轴坐标
				let nowY = me.clientY; //当前位置的y轴坐标
 
				let moveX = defaultX - nowX; //在x轴上的移动距离
				let moveY = defaultY - nowY; //在y轴上移动的距离
 
				let nowLeft = defaultLeft - moveX; //当前位置左侧偏移量
				let nowTop = defaultTop - moveY; //当前位置顶部偏移量
 
				btnEle.style.left = `${nowLeft}px`; //将当前位置赋值给帮助按钮
				btnEle.style.top = `${nowTop}px`;
			};
 
			//鼠标抬起时
			btnEle.onmouseup = () => {
				btnEle.style.cursor = "default"; //重置鼠标样式
				//清除事件
				btnEle.onmousemove = null;
				btnEle.onmouseup = null;
			};
		};
	</script>
```



### vue相关知识

#### 1.vue的响应式原理

```js
Object.defineProperty怎么用， 三个参数？，有什么作用啊？
     Object.defineProperty() 方法会直接
     vue2响应式的缺点：只能监听对象属性的读取和修改，如果想要删除或增加就无法响应式刷新页面，必须借助this.$set;
通过下标或length修改数组也不会响应式刷新页面，是通过使用pop，push等这几种数组方法操作数组才是响应式的，而数组方法 map 就是
用一种新的思路让新增的数组属性具有响应式,如 map 方法把旧数组返回到一个新数组上,如果你在旧数组添加了这个元素,然后返回给了一个新数组,那么这个元素也具有响应式；在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
     Object.defineProperty(obj, prop, {})
     obj：需要定义属性的对象
     prop：需要定义的属性
     {}：要定义或修改的属性描述符。
     value: "18",         // 设置默认值得
     enumerable: true,    //这一句控制属性可以枚举 enumerable 改为true 就可以参与遍历了   默认值false
     writable: true,      // 控制属性可以被修改   默认值false
     configurable: true,  // 控制属性可以被删除   默认值false
      get // 当有人读取 prop 的时候  get函数就会调用,并且返回就是 sss 的值
      set // 当有人修改 prop 的时候  set函数就会调用, 有个参数这个参数就是修改后的值

      this.$set( target, key, value )
    //target：要更改的数据源(可以是对象或者数组)
    // key：要更改的具体数据
    //value ：重新赋的值

 //vue的删除数组和原生删除数组的区别delete
**删除数组**
1. delete只是把数组元素的值变成empty/undefined，元素的键不变，数组长度不变。
2. Vue.$delete(array,index)直接删除数组，改变数组的键值和长度。是响应式的
**删除对象**
两者相同，都会把键名（属性/字段）和键值删除。但是delete不是响应式的，而this.$delete是响应式的，而在vue3当中，我们直接使用delete删除对象的属性也是响应式的。

```

**1.1.vue2响应式原理**（上次面试问到没回答清楚）

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过**Object.defineProperty()来劫持各个属性的setter**，**getter**，在数据变动时发布消息给订阅者，触发相应的监听回调。 **具体步骤：** 

**第一步：** 需要 **observe** 的数据对象进行递归遍历，包括子属性对象的属性，都加上 **getter** 和**setter** ，这样的话，给这个对象的某个属性赋值，就会触发 setter，那么就能监听到了数据变化

**第二步：**  **compile 解析模板指令**，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

**第三步：**  **Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁**，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 **update()** 方法 3、待属性发生变化， **dep.notice()** 通知时，调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。

第四步（这一步应该不算，不需要记）：MVVM 作为数据绑定的入口，整合 **Observer、Compile 和 Watcher** 三者，通过 Observer 来监听自己的 model 数据变化， 通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新； 视图交互变化(input) -> 数据 model 变更的双向绑定效果。

**vue2和vue3响应式原理区别**

在vue2中只能监听对象属性的读取和修改，如果想要删除或增加就无法响应式刷新页面，必须借助this.$set才能添加属性，只能使用this.$delete（）才能响应式删除对象内的属性;通过下标或length修改数组也不会响应式刷新页面，是通过使用pop，push等这几种数组方法操作数组才是响应式的。而在vue3中这些问题都得以解决，vue3是利用Proxy通过Proxy（代理），拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。通过Reflect（反射）：对被代理对象的属性进行操作。不需要像vue2中需要给每一个对象的属性都添加上监听才能实现响应式，只需要给对象的最顶层添加代理，对象任意层级属性发生变化都可以监听到。

**为什么使用reflect？**

 ECMA正在尝试将Object中很多有用的API,移植到Reflect身上。  例如：Object身上有的Object.defineProperty()，Reflect身上也有，当通过Object.defineProperty()给某个对象属性添加响应式，后面你又给这同一个属性添加了响应式整个代码就会挂掉；用Reflect.defineProperty()去追加属性的时候，即使重名，也不会报错；但是只有第一次追加的值才生效；且Reflect.defineProperty是有返回值的，由于第二次代码是错误的，所有会返回false，方便我们分析错误，而Object.defineProperty()必须借助try catch才可以实现这样的功能

#### 2.vue虚拟dom（4.16面试问到了，没回答清除）

虚拟 DOM（根据模板使用createElement方法生成一个js对象，注意document.querySelector获取到的是真实dom的引用，而不是虚拟dom），就是用对象的方式取代真实的 DOM 操作，当页面打开时浏览器会解析 HTML 元素，构建一颗 DOM 树，将这棵dom树状态全部保存起来，在内存当中模拟我们真实的 DOM 操作，操作完后会生成一颗 虚拟dom 树，根据 diff 算法比较两颗 DOM 树不同的地方，只将不同的地方进行重新渲染，通过最小化的dom操作，就实现了高效的渲染和更新元素，避免了直接操作真实dom，引发回流或重绘，从而提高了浏览器的性能。

例如，一个 ul 标签下很多个 li 标签，其中只有一个 li 有变化，这种情况下如果使用新的 ul 去替代旧的 ul,因为这些不必要的 DOM 操作而造成了性能上的浪费，但是如果直接使用虚拟节点覆盖旧节点的话，减少了很多的不必要的 DOM 操作。

缺点：首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。


#### 3.diff算法

diff 算法是一种通过同层的树节点进行比较的深度优先算法,比较方式：diff整体策略为：深度优先，同层比较

diff算法 当data发生改变 会根据新的数据生成一个新的虚拟dom ，新的虚拟dom和旧的虚拟dom进行对比，这个对比的过程就是diff算法，会找到不同地方，只去渲染不同的地方，总的来说就是减少DOM，重绘和回流。

详细的对比流程是（是根据新的来排旧的数组，旧的才是我们要的）

首先，我们拿到新旧节点的数组，然后初始化四个指针，分别指向新旧节点的开始位置和结束位置，进行两两对比，（就四种对比方式啊，新开始和旧开始；新结束和旧结束；新开始和旧结束；新结束和旧开始）1.若是 新的开始节点和旧开始节点相同，则都向后面移动指针，2.若是结尾节点相匹配，则都前移指针。3.若是新开始节点和旧结尾节点相同上了，则会将旧的结束节点移动到旧的开始节点前。4.若是旧开始节点和新的结束节点相匹配，则会将旧开始节点移动到旧结束节点的后面。若是上述节点都没配有匹配上，则会进行一个兜底逻辑的判断，判断新的开始节点是否在旧节点中存在，若是存在则复用这个旧节点，若是不存在则在旧的开始节点新建一个这个节点。最后当新的开始节点指针大于新的结束节点，说明对比已经结束，也就说明旧的开始到结束节点之间的节点是新节点中不存在的，删除此时旧开始与旧结束指针之间的节点。vue 的diff算法是个深度优先算法

#### 4.vue中key 的作用 

##### key某些时候不能使用index的原因 https://blog.csdn.net/cun_king/article/details/120714227

key在Vue是DOM对象的标识，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode（虚拟）节点，更高效的对比新旧虚拟DOM中每个节点是否是相同节点，相同就复用，不相同就删除旧的创建新的；注意在顺序不变的时候直接使用index作为key是可行的，而顺序发生变化就不要使用index，容易造成渲染错误，因为如果你在首部插入新生成的节点，那么原先的index=0的节点就变成了你新生成的节点，原先index=0的节点的index也跟着改变了，实际上这个节点并没有删除，所有会造成渲染错误；

#### 5.methods与computed区别

1.methods属性内的方法调用可以加括号，而computed属性内的方法调用不能加括号，就和常量的使用一样

2.computed计算属性有缓存，当一个computed在同时在一个页面使用两次，只会调用第一次，第二次用的是缓存，methods没有缓存，需要执行多次。所以计算属性效率更高

3.计算属性是一个属性，必须要有return返回值，methods可有可无

#### 6.watch和computed区别	

1.computed支持缓存，相依赖的数据发生改变才会重新计算；watch不支持缓存，只要监听的数据变化就会触发相应操作		

2.computed不支持异步，当computed内有异步操作时是无法监听数据变化的；watch支持异步操作**（这是最重要的地方）**

3.是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。

4.computed的监听是页面初始化的时候就开始的，而watch默认第一次加载不监听，需要自己immediate:true开启才行

4.使用场景：computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----比如搜索框我做的那个地图项目，点击某个区域，仓库中存储的



#### 7.v-if和v-show的区别及使用场景？

1.v-if 动态的创建或者销毁元素；v-show 是控制元素的显示或者隐藏，实际上就是利用display：block，none

2.由于v-if 创建或者销毁元素，有更高的切换消耗，而 v-show 有更高的初始化渲染消耗，一般推荐频繁切换的时候使用 v-show 更好，当切换频率不是特别频繁；或判断分支比较多的时候；以及首次渲染的时候 使用v-if

#### 8.v-if和v-for的优先级以及解决一起使用的方式

很好理解，vue2到vue3肯定是要进步的，所以vue2是v-for优先，因为然后当全部节点生成之后再去if判断删除掉为false的节点，不如先v-if节约性能；

v-for和v-if虽然可以一起使用，但是不应该一起使用，因为`v-for`比`v-if`优先，即每一次都需要遍历整个数组，然后等v-for全部遍历完再进行判断将不符合要求的删掉，会大量消耗不必要的内存，引起浏览器的回流重绘，影响浏览器加载速度。

![image-20240319202238984](assets/image-20240319202238984.png)



#### 9.数据双向绑定的原理（这里我理解的是v-model的原理）

https://blog.csdn.net/Zhang_wang_yun/article/details/131344048



#### 10.vue生命周期（记得keep-alive的也要说）

beforeCreate() 创建前，这个时候data中的数据，还未定义，所以不能使用
created()创建后 最早开始访问到 data和methods，computed，watch中数据或方法的生命周期钩子，在此时我们就可以发起ajax请求

beforeMount()挂载前 指令已经解析完毕，内存中已经生成dom树，但是尚未挂载到页面中去，此时页面还是旧的。
mounted()挂载后 dom已经渲染完毕，此时页面和内存中都是最新的数据，现在就可以操作DOM元素

 beforeUpdate()更新前 当视图层的数据发生改变会执行这个钩子 内存中数据已经更新，但是DOM节点还未更新，数据还没有与页面同步
 updated()更新后 数据更新完成以后触发的钩子，此时DOM节点已经更新

 beforeDestroy()即将销毁 data和methods中的数据此时还是可以使用的，可以做一些释放内存的操作，比如销毁定时器，解绑全局事件，移除监听事件等
 destroyed()销毁完毕  组件已经全部销毁，Vue实例已经被销毁，Vue中的任何数据都不可用

 其他三个：

keep-alive的大致用法，再次回到该页面的时候使用的是缓存：https://blog.csdn.net/code_dream_wq/article/details/128713825     

activated  被 keep-alive 缓存的组件激活时调用。组件初始化时不会被调用，因为第一次使用的不是缓存，第二次访问这个路由才会被调用，和上面的生命周期钩子一样使用方法
deactivated 被 keep-alive 缓存的组件停用时调用，当离开缓存的路由组件时被调用。

errorCaptured 当捕获一个来自子孙组件的错误时被调用，此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播



#### 11.vue2和vue3的区别

1.响应式原理发生变化，vue2是利用Object.defineProperty()对数据进⾏劫持 结合 发布订阅模式的⽅式来实现的；vue3 中使⽤了 ES6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每⼀个对象都包⼀层 Proxy，通过 Proxy 监听属性的变化，从⽽ 实现对数据的监控。

2.Vue2使用 选项式API（Options API）；当一个数据发生变化，需要在data，method。computed当中依次去修改代码； Vue3 组合式API（Composition API）中将数据和方法都定义在了setup里面，修改更方便，更加的贴近于模块化

3.vue2中每一个组件必须有一个根标签，而vue3中不需要有根标签，有利于减少内存

4.生命周期发生变化

创建前：beforeCreate -> 使用setup()
创建后：created -> 使用setup()
挂载前：beforeMount -> onBeforeMount
挂载后：mounted -> onMounted
更新前：beforeUpdate -> onBeforeUpdate
更新后：updated -> onUpdated
销毁前：beforeDestroy -> onBeforeUnmount
销毁后：destroyed -> onUnmounted
异常捕获：errorCaptured -> onErrorCaptured
被激活：onActivated 被包含在<keep-alive>中的组件，会多出两个生命周期钩子函数。被激活时执行。
切换：onDeactivated 比如从 A 组件，切换到 B 组件，A 组件消失时执行
5.vue3中对typescript的支持比vue2好的多

6.重写虚拟 DOM ，随着虚拟 DOM 重写，减少 运行时（runtime）开销。将包括更有效的代码来创建虚拟节点。



#### 12.常见的组件通信方式

https://blog.csdn.net/qq_54753561/article/details/122281196

.sync（子组件用props接收传递过来的属性）

```js
//父组件
 <div class="">
     //这里的这个v-bind:value1的这个value1可以任意取值，在子组件中props引入时的名字需要和这个一致
    <Ceshi :value1.sync="val"></Ceshi>
    {{ val }}
  </div>

<script>
import Ceshi from './components/Ceshi.vue'
export default {
  name:'App',
  data() {
    return {
      val: "我是Home里的数据 响应式的",
    };
  },
  components:{Ceshi},
};
</script>

//子组件
<template>
    <input class="i911-sync" :value="value1" @input="handleInput" />
  </template>
  <script>
  export default {
    name: "Ceshi",
    props: {
      value1: {
        type: String,
        default: "",
      },
    },
    methods: {
      handleInput(event) {
          //这个更新函数形式是固定的update:后面跟的是你props引入的那个值的属性名，不是固定说必须用value
        this.$emit("update:value1", event.target.value);
        console.log(this.$props)
      },
    },
  };
  </script>

```



#### 13.跨域

**JSONP的基本原理是利用`<script>`标签的`src`属性没有跨域限制的特性来实现跨域数据访问。** 在使用JSONP时，需要在客户端创建一个`script`标签，将需要访问的资源URL以参数形式通过script标签的src传递给服务器，服务器在接收到请求后，将数据装入一个函数调用中返回给客户端，这个函数就是在客户端预先定义好的回调函数。缺点是只有jsonp只支持get请求，不支持post等其他http请求；由于jsonp请求是通过script标签实现，所以我们无法设置请求头，也无法获取响应头。

![image-20240310161327515](assets/image-20240310161327515.png)

代理跨域

https://blog.csdn.net/marendu/article/details/103733286

由于同源协议会导致跨域，代理跨域就是利用服务器和服务器之间不存在跨域问题，配置一个代理服务器，让代理服务器向服务器发请求，服务器收到请求并返回结果给代理服务器，然后代理服务器再将请求结果返回给我们真正需要用到的地方。

```js
//  cli3     vue.config.js
  devServer: {
    proxy:{
      "/api": {
          target: "http://www.xiongmaoyouxuan.com", // 需要代理的域名
           ws: false, // 是否启用websockets
          changeOrigin: true, //允许跨域 可以代理反向的地址，在生产环境当中可以不设置，当设置为true，请求头中的origin属性会被改变为目标服务器的地址，以避免跨域问题
          pathRewrite: {  //重写匹配的字段，重写为""，让服务器收到的是你真正发起请求的那个字段
              "^/api": ""
          }
      },
  },
  }

//然后在创建axios的时候，beseURL这样如下配置，这个baseUrl的作用就是在你使用下面这个axios的时候 所有端口号后字段添加/api这个字段
const ajax = axios.create({
    baseURL:"/api",
})
//当我们碰到/api开头的请求地址，就会知道这个地址需要代理跨域
```

#### 14.什么是ajax？ajax有什么优缺点？

ajax不是语言，ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术

优点

1、最大的一点是页面无刷新，用户的体验非常好。

2、使用异步方式与服务器通信，具有更加迅速的响应能力。

缺点

1、ajax不支持浏览器back按钮。

3、对搜索引擎的支持比较弱。

4、破坏了程序的异常机制。

5、不容易调试

```js
//1.创建xhr 核心对象
var xhr=new XMLHttpRequest();

//2.调用open 准备发送
//参数一：请求方式
//参数二: 请求地址
//参数三：true异步，false 同步
xhr.open('post','http://www.baidu.com/api/search',true)

//3.如果是post请求，必须设置请求头。
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')

//4.调用send 发送请求 （如果不需要参数，就写null）
xhr.send('user=tom&age=10&sex=女')

//5.监听异步回调 onreadystatechange
//判断readyState 为4 表示请求完成
//判断status 状态码 为 200 表示接口请求成功
//responeseText 为相应数据。字符串类型。
xhr.onreadystatechange=function(){
    if(xhr.readyState==4){ 
        if(xhr.status==200){
            console.log(xhr.responseText);
            var res=JSON.parse(xhr.responseText);
            console.log(res);
            if(res.code==1){
            modal.modal('hide');
           location.reload();
       }
    }
            
            
//备注：如果是post请求，想要传json格式数据。
//设置请求头

xhr.setRequestHeader('Content-Type', 'application/json')

//open发送数据
xhr.open({_id:xxx,user:xxxx,age:xxxx})
```



#### 15.axios

Axios是一个基于[promise](https://so.csdn.net/so/search?q=promise&spm=1001.2101.3001.7020)的HTTP库，类似于jQuery的ajax，用于发起http请求，也支持promise的一些用法。

可以和面试官讲用法，比如我们在做项目的时候一般会对axios进行二次封装，方便我们复用，首先我们利用axios.create（）创建axios的实例，然后配置baseURL以及timeout，最长响应时间。然后可以配置请求拦截器，然后可以设置登录的判断，如果存在token，就讲token配置到请求头上，因为有一些接口我们设置有需要token的请求头；我们还可以设置比如请求加载的进度条,然后添加一个当提示有错误信息的配置项即可；然后在响应拦截器中配置当状态码为200和20000的时候为请求成功；其他为失败，并打印出失败的结果，然后我们就可以在统一配置请求接口的地方利用这个axios发起http请求。而且还有如axios.all这个有promise.all封装来的可以实现并发处理请求的方法，可以实现同时发起多个请求，并等待全部请求结果返回之后同时处理请求结果的业务。

```js
// 引入进度条
import nprogress from "nprogress"
// 光引入进度条没用 显示不出进度条 还要引入进度条样式
import "nprogress/nprogress.css"

let instance = axios.create({ });
instance.interceptors.request.use(config=>{ 
    //token存在就配置请求头
     if (store.getters.token) {
      config.headers.token = getToken()
    }
    //开始进度条  ，需要在响应拦截器中去配置停止进度条
     nprogress.start()
    return config,
    (err) => { 
        // 在请求错误的时候的逻辑处理
        return Promise.reject(err);
      }

})
```

```js
//响应拦截器
service.interceptors.response.use(response => {
    const res = response.data
    // console.log(res)
    // 服务器响应失败再干什么  这里为什么20000和200都要加上 因为这里mock数据成功code是20000，真实接口成功回调code是200
    if (res.code !== 20000 && res.code !== 200) {
      Message({
        message: res.message || 'Error',
        type: 'error',
        duration: 5 * 1000
      })

      // 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired;
      if (res.code === 50008 || res.code === 50012 || res.code === 50014) {
        // to re-login
        MessageBox.confirm('You have been logged out, you can cancel to stay on this page, or log in again', 'Confirm logout', {
          confirmButtonText: 'Re-Login',
          cancelButtonText: 'Cancel',
          type: 'warning'
        }).then(() => {
          store.dispatch('user/resetToken').then(() => {
            location.reload()
          })
        })
      }
      return Promise.reject(new Error(res.message || 'Error'))
      // 服务器响应成功干什么
    }
    else {
      return res
    }
  },
  error => {
    console.log('err' + error) // for debug
    Message({
      message: error.message,
      type: 'error',
      duration: 5 * 1000
    })
    return Promise.reject(error)
  }
)
```

#### 16.promise

1、Promise 是异步编程的一种解决方案，主要用于异步计算，支持链式调用，可以解决回调地狱 的问题，自己身上有all、reject、resolve、race 等方法；

2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果，可以在对象之间传递和操作 promise，帮助我们处理队列

3、promise 有三个状态：pending[待定]初始状态，fulfilled[实现]操作成功，rejected[被否决]操作失败

4、Promise 对象状态改变：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了

5、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部，但是写了then 和 catch ，会被then的第二个参数 或 catch所捕获

```js
//回调地狱就是回调函数嵌套回调函数，然后上一个回调函数请求回来的结果需要作为这一个请求的参数；如果嵌套多了，就是回调地狱。
<script>
        //通过ajax请求拿到用户id
        $.ajax({
            type:"GET",
            url:"./data1.json",
            success:function(res){
                let {id} = res;
                console.log(id);

                //通过用户id找到用户名
                $.ajax({
                    type:"get",
                    url:'./data2.json',
                    data:{id},
                    success:function(res){
                        let {username} = res;
                        console.log(username);

                        //通过用户名找到用户邮箱
                        $.ajax({
                            type:"GET",
                            url:"./data3.json",
                            data:{username},
                            success:function(res){
                                let {email} = res;
                                console.log(email);
                            }
                        })
                    }
                })
            }
        })
    </script>

//利用promise解决，封装成一个函数
//封装Ajax请求函数
function getAjax(path,data){
   return new Promise((resolve,reject)=>{
        $.ajax({
            type:'get',
            url:path,
            data:{data},
            success:function(res){
                resolve(res)
            },
            error:function(res){
                reject(res)
            }
        })
    })
}

getAjax('./data1.json')
.then((value)=>{
    let id = {value};
    return getAjax("./data2.json",id)
})
.then((value)=>{
    let {username} = value;
    return getAjax('./data3.json',username)
})
.then((value)=>{
    console.log(value);
})



```

`Promise.all(promises)` —— 等待所有 promise 都 resolve 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 reject，那么它就会变成 `Promise.all` 的 error，所有其他 promise 的结果都会被忽略

![image-20240317120125181](assets/image-20240317120125181.png)

`Promise.race(promises)` —— 等待第一个 settle 的 promise，并将其 result/error 作为结果返回。

`Promise.resolve(value)` —— 使用给定 value 创建一个 resolved 的 promise。实际上是new Promise(resolve => resolve());



`Promise.reject(error)` —— 使用给定 error 创建一个 rejected 的 promise。

原型上有then、catch等方法。

promise.finally方法：无论成功还是失败，都会执行

![image-20240317155400917](assets/image-20240317155400917.png)

#### 17.async，await（这篇文章讲的还行可以看看）是生成器和promise的语法糖

https://blog.csdn.net/weixin_45811256/article/details/123638582

这篇文章看看https://blog.csdn.net/bingbing1128/article/details/122203832

async，await是异步编程的最终解决方式，让异步代码看着像是同步代码。

1.`await`必须写在`async`函数中, 但async函数中可以没有await
2。如果await的promise失败了, 就会抛出异常, 需要通过`**try…catch**`来捕获处理。所以如果只有一个异步请求的时候，直接用promise比用async，await反而更加的方便，而如果是多个异步请求，那当然用async，await好一些，await 能够获取promise执行的结果 await必须和async一起使用才行，async配合await使用是一个阻塞的异步方法

如果await后面不是Promise对象, 就直接返回对应的值，只能在async函数中出现, 普通函数直接使用会报错

await语句后的Promise对象变成reject状态时，那么整个async函数会中断，后面的程序不会继续执行


await后面的代码还是要执行的，根据情况判断，同步执行，异步放入微任务或红任务队列，而不是全部延后执行，await下面的代码才是被阻塞的代码，当await的代码执行完之后先执行函数外部的代码，同步执行，异步放入队列，最后在执行被阻塞的代码

```js
  async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
    setTimeout(() => {
      console.log('timer1')
    }, 0)
  }
  async function async2() {
    setTimeout(() => {
      console.log('timer2')
    }, 0)
    console.log('async2')
  }
  async1()
  setTimeout(() => {
    console.log('timer3')
  }, 0)
  console.log('start')
// async1 start => async2 => start => async1 end => timer2 => timer3 => timer1


// 注意：如果async函数中有返回值，当调用该函数时，内部会调用Promise.resolve()方法把它转化成一个promise对象作为返回；如果没用返回值，那么timeout()这个promise的结果为undefined

async function timeout() {
      return 'hello world!'
    }
//timeout()返回的就是一个promise，状态为已完成，结果为hello world，所以这个函数调用可以使用then接收
    timeout().then(val => {
      console.log(val)
    })
    console.log('我虽然在后面，但是先执行')

```

#### 18.父子组件的声明周期执行顺序

https://blog.csdn.net/m0_73490373/article/details/132010940



#### 19.mixins混入（面试官问到过，封装一些复用的方法或属性会用到）

https://blog.csdn.net/qq_41809113/article/details/121912330

**注意，如果和组件内属性或方法重名，优先用组件本身的**

混入就是创建一些可以复用的方法，供其他组件使用，混入可以全局混入，但是一般不推荐使用；一般使用的混入就是局部混入如下先创建混入，然后导出

![image-20240319213726296](assets/image-20240319213726296.png)

然后在需要使用的组件引入，即可使用

![image-20240319213749946](assets/image-20240319213749946.png)

#### 20.路由（看笔记）

https://blog.csdn.net/qq_55593227/article/details/119717498



#### 21.vuex仓库（看笔记）

https://blog.csdn.net/qq_55593227/article/details/119717498

1.getters其实也是有作用的，假如你想不经过任何条件触发获取到state的数据，比如我做的那个地图，原本我是监听返回的state的数据，相当于直接操作了state，我可以利用getter拿到state，然后我监听这个getter方法也可实现，这就是getter的用法，还是有用的

2.action 主要是可以干一些异步操作，比如发起http请求获取到数据，但是不能通过action直接改变state，在组件中利用的是dispatch获取

3.mutation就是可以唯一可以修改state数据的地方，利用的是commit在组件中，getter不能修改

4.mapActions与mapMutations在methods中利用...使用，且数组形式可以简写，而对象形式不能简写，mapState，mapGetters在computed中使用如...mapMutation:['a'] ,这个a函数的参数我们直接在如点击事件调用a方法的时候传递如@click='a(n)'   ,并且这些语法糖都需要在用到组件中利用vuex引入。开启命名空间后引入方式发生变化，如countStore和personStore两个仓库	...mapMutations('countStore',{increment:'increment',decrement:'decrement'}),

...mapMutations('countStore',['increment','decrement'])等价；

不使用语法糖this.$store.commit('personStore/ADD_PERSON',personObj)；

​                        this.$store.state.countStore.sum   

注意state和其他的开启命名空间引入方式不一样

5.当你在不同模块中namespaced:true,可以开启命名空间，然后就可以模块化vuex仓库

```js
//引入Vue核心库
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'
//引入count仓库内容
import countOptions from './count'
//引入person内容
import personOptions from './person'
//应用Vuex插件
Vue.use(Vuex)
   
//创建并暴露store
export default new Vuex.Store({
    modules:{
        //这里键值对一致可以缩写
        countAbout:countOptions,
        personAbout:personOptions,
    }
})

```

6.不能直接修改vuex仓库的state,因为vuex是[单向数据流](https://so.csdn.net/so/search?q=单向数据流&spm=1001.2101.3001.7020)，如果在组件中可以直接修改state数据就违背了vuex这个仓库了，单向数据流指只能从一个方向来修改状态，也就是必须通过action修改mutation，再通过mutation去修改state。还有就是如果我们想要异步修改state呢，使用mutation修改的话我们可以在vue的调试工具devtools中看到我们每一次修改的状态，而直接修改state是看不到的

#### 22.自定义指令

https://blog.csdn.net/m0_64346035/article/details/125317756

![image-20240319212611774](assets/image-20240319212611774.png)

实现一个拖拽的自定义指令

```js
//注意我们需要给需要拖拽这个属性子绝父相，不然就用不了left和top属性了
<div ref="a" id="bg" v-drag></div>
 
 Vue.directives: {'drag', {
      bind() {},
     //el就是你绑定自定义指令那个元素，并且是已经通过document.quertSelector获取到的，只需要添加事件即可
      inserted(el,binding) {
          //注意mousemove事件是在鼠标点击事件内部
        el.onmousedown = (e) => {
          let x = e.clientX - el.offsetLeft;
          let y = e.clientY - el.offsetTop;
          document.onmousemove = (e) => {
            let xx = e.clientX - x + "px";
            let yy = e.clientY - y + "px";
            el.style.left = xx;
            el.style.top = yy;
          };
          el.onmouseup = (e) => {
              //当松开鼠标的时候 解绑鼠标移动事件
            document.onmousemove = null;
          };
        };
      },
    },
  }
```



#### 23.nexttick

https://blog.csdn.net/z1902737007/article/details/103769201

this.$nextTick的作用就是可以在dom更新后调用自身的回调，

用处：

1.是我们可以在creacted操作dom，虽然此时dom都没有挂载，页面还是旧的，以及虽然vue不赞成我们直接操作dom，但是有时候我们依然需要直接操作dom。

2.就是点击之后自动聚焦，比如我前段时间做的面包屑利用v-if切换，存在元素的新建和销毁，当从div标签切换到输入框需要自动聚焦，就需要用到nexttick，不然无法自动聚焦

Vue在观察到数据变化时并不是直接更新DOM，而是开启一个队列，并缓冲在同一个事件循环中发生的所有数据改变，当所有的更新完毕之后才更新dom。在缓冲时会去除重复数据（就是如果你执行for循环改变了一百次一个元素，dom去重只获取最后一次的变化），从而避免不必要的计算和DOM操作，以及页面的回流和重绘。Vue会根据当前浏览器环境优先使用原生的Promise.then和MutationObserver，如果都不支持，就会采用setTimeout代替。

```js
//这里我由一个疑惑，如果此处这个div标签内我放的是一个{{value}}，这个value是我在data声明的，当这个标签显现我给这个value赋一个新的值，拿到的是新的那个值吗，我觉得应该是
<div id="app">
<div id="div1" v-if="showDiv">这是一段文本</div>
    <button @click="getText">获取div内容</button>
</div>
<script>
var app = new Vue({
    el : "#app",
    data:{
        showDiv : false
    },
    methods:{
        getText:function(){
            this.showDiv = true;
            this.$nextTick(function(){
                //此处直接操作dom很明显，不使用nexttick获取到的就是更新前的元素内容
                
                  var text = document.getElementById('div1').innnerHTML;
                 console.log(text);  
            });
        }
    }
})
</script>

```

#### 24.v-text和{{}}和v-html区别

1.v-text和{{}}表达式渲染数据，不解析标签，如果有标签则直接当做字符输出到页面上。

2.v-html不仅可以渲染数据，而且可以解析标签。



#### 25.vue首屏加载过慢的优化

分析问题:网络延时问题,资源文件体积是否过大,请求资源是否过多,资源是否重新发送请求去加载,加载脚本的时候渲染内容阻塞了

1.使用路由懒加载的方式，通过import来实现路由的动态加载，这属于减少加载模块的优化

```js
{
     path: '/goodList',	//path路径	
     name: 'goodList',	//组件名
     component: () => import('../components/goodList')
},
```

2.图片懒加载，在vue中使用vue-lazyload实现，这属于减少请求次数或体积的优化。

使用精灵图的方式减少小图标总请求数也算小的优化

```js
// 下载依赖  npm install vue-lazyload --save

//main.js 文件
import VueLazyload from 'vue-lazyload'	//引入依赖
Vue.use(VueLazyload)
// 配置项
Vue.use(VueLazyload, {
  preLoad: 1.3,	//表示lazyload的元素,距离页面底部距离的百分比.计算值为(preload - 1)，默认值为1.3
  error: 'dist/error.png',	//加载失败后图片地址
  loading: 'dist/loading.gif',	//加载时图片地址
  attempt: 1	//	图片加载失败后的重试次数，默认值为3
})
```

3.通过webpack开启gzip压缩文件传输模式，通过减少文件体积来提高加载速度。html、js、css文件甚至json数据都可以用它压缩，可以减小60%以上的体积。这属于缩小项目体积的优化方式，貌似还要在nginx中也开启gzip

在vue.config.js文件中，如下

```js
const CompressionPlugin = require('compression-webpack-plugin');//引入gzip压缩插件
module.exports = {
    plugins:[
        new CompressionPlugin({//gzip压缩配置
            test:/\.js$|\.html$|\.css/,//匹配文件名
            threshold:10240,//对超过10kb的数据进行压缩
            deleteOriginalAssets:false,//是否删除原文件
        })
    ]
}
```

4.通过对css3、js文件的合并，如在两不同组件中，拥有相同的样式，可通过全局css文件中设置。在js文件上，将相同的方法封装合并成一个方法，如API请求，属于缩小项目体积的优化

5.网络请求中需要用的静态资源使用cdn分布式网络

6.wepack中配置树摇删除不必要的代码

7.善用http缓存,就是协商缓存或者强制缓存 

8.合理的使用webworker加载计算量很大的js文件

#### 26.vuex数据持久化存储

1.在vuex仓库中里面localStorage存储，首先我们可以在 state中进行localStorage对数据进行存储，然后在mutations下有一个修改方法。

![image-20240328110334052](assets/image-20240328110334052.png)

2.使用插件进行持久化存储（vuex-persist）

首先npm下载插件 ：npm install vuex-persist -s

vuex：store.js文件内容如下

```js
import Vue from 'vue'
import Vuex from 'vuex'
// 1. 导入包
import VuexPersistence from "vuex-persist"
 
Vue.use(Vuex)
 
export default new Vuex.Store({
  // 2. 配置为 vuex 的插件
  plugins: [createPersistedState()],
  state: {
    token: ''
    ...
  },
    action:{},
    mutation:{},
    
    //在vuex仓库中直接使用插件
    plugins: [ VuexPersistence({
  // 默认的是localStorage存储，可以修改成会话存储（window.sessionStorage）
  storage:window.localStorage
})]
    
})
```

#### 27.$refs的缺陷

1.mounted 不会保证所有的子组件也都被挂载完成。所以如果我们在父组件mounted的时候使用ref获取子组件时，可能会出现获取不到这个子组件的情况，我们就必须用this.$nextTick(()=>{ } )，将ref放在这个回调里面，在整个视图都被渲染之后运行这个代码，这个钩子在服务端渲染期间不会被调用。

2.会使父组件和子组件之间形成了紧密的耦合关系，这使得组件变得更加脆弱，如果其中一个组件发生了变化，则可能导致另一个组件无法正常工作。

#### 28.vue常见的一些修饰符，如.trim()  .stop()

https://blog.csdn.net/MiemieWan/article/details/111934238



#### 29.插槽

1. **默认插槽**

![img](assets/default_slot.png)

```vue
父组件中：
        <Category title="今日热门游戏">
          <ul>
            <li v-for="g in games" :key="g.id">{{ g.name }}</li>
          </ul>
        </Category>
子组件中：
        <template>
          <div class="item">
            <h3>{{ title }}</h3>
            <!-- 默认插槽   如果没有在父组件传递内容给插槽，那么插槽标签内的123就会显示，起到一个默认值的效果 -->
            <slot>123</slot>
          </div>
        </template>
```

2. **具名插槽（假如子组件有三个slot标签，那么在父组件内传入结构的时候，必然需要区分开这三个slot标签分别传递的内容，这就是具名插槽和默认插槽的区别）**

注意：具名插槽在vue3有语法糖，直接写 #s2 就相当于写了 v-slot:s2

```vue
父组件中：
        <Category title="今日热门游戏">
// v-slot:s1的意思就是我要将下面这个ul标签放在名字为s1的插槽里面，注意一点，vue3规定了v-slot只能放在组件标签或者  template标签上，如果这里直接放Category标签上，要是只有单个具名插槽就可以，但是如果有多个就不行，就必须加上一个template标签
          <template v-slot:s1>
            <ul>
              <li v-for="g in games" :key="g.id">{{ g.name }}</li>
            </ul>
          </template>
            
          <template #s2>
            <a href="">更多</a>
          </template>
        </Category>
子组件中：
        <template>
          <div class="item">
            <h3>{{ title }}</h3>
            <slot name="s1"></slot>
            <slot name="s2"></slot>
          </div>
        </template>
```

**3. 作用域插槽 （封装组件经常用到，我使用饿了么ui的时候就经常用到）**

1. 理解：<span style="color:red">数据在组件的自身，也就是子组件上，但根据数据生成的结构需要组件的使用者也就是父组件来决定。这个时候由于数据存在跨组件，也就存在作用域问题</span>，所以我们需要用到作用于插槽（新闻数据在`News`组件中，但使用数据所遍历出来的结构由`App`组件决定）

2. 作用域插槽也分有名和没名，没名如下代码，有名如果name=’s1‘  那么父组件就要v-slot：s1='params'或#s1=’params‘即可，然后如果用到解构也就成了#s1='{games}'  不难 大约记住写法就行了    没名插槽其实有默认名字v-slot:default="params"

3. 具体编码：

   ```vue
   父组件中：如下就会分别生成一个无序列表和有序列表，并且数据是并不是自己的，而是插槽内部传递过来的
   //此处这个params里面就包含从slot标签传递过来的所有props数据，是一个对象,一般情况props肯定的是父传子，这里肯定是内部封装了的，也是比较好理解的
         <Game v-slot="params">
           <ul>
             <li v-for="g in params.games" :key="g.id">{{ g.name }}</li>
           </ul>
         </Game>
   //如上每一次拿到params.games都很烦因为一直要先拿到对象，所以我们可以解构，这样就可以直接获取到params里面的games
     <Game v-slot="{games}">
       
           <ol>
             <li v-for="g in params.games" :key="g.id">{{ g.name }}</li>
           </ol>
         </Game>
   子组件中：
         <template>
           <div class="category">
             <h2>今日游戏榜单</h2>
               //利用props传递了两个参数
             <slot :games="games" a="哈哈"></slot>
           </div>
         </template>
   
         <script setup lang="ts" name="Category">
           import {reactive} from 'vue'
           let games = reactive([
             {id:'asgdytsa01',name:'英雄联盟'},
             {id:'asgdytsa02',name:'王者荣耀'},
             {id:'asgdytsa03',name:'红色警戒'},
             {id:'asgdytsa04',name:'斗罗大陆'}
           ])
         </script>
   ```

#### 30.vue中render函数的作用以及vue2和vue3当作render区别

https://blog.csdn.net/weixin_43974265/article/details/112747768 这篇文章讲的不错

其实template方式实例化组件的内部也是使用了render函数,render函数就是利用js的方式生成组件

**1.render函数的作用**:`render` 函数即渲染函数，它是个函数，它的参数 `createElement` 也是个函数。createElement这个函数的作用就是生成一个 VNode节点，render 函数得到这个 VNode 节点之后，返回给 Vue.js 的 mount 函数，渲染成真实 DOM 节点，并挂载到根节点上。createElement包含三个参数,具体看上面链接.

**2.vue2和vue3中render函数的区别**:查不到太多相关的资料,只能说vue2中render函数返回的虚拟dom对象中包含了描述dom结构的信息vue3render函数返回的虚拟dom中包含更多的属性,如属性的props,事件监听器等;

**3.template和render函数的区别**

利用template的方式,可以看出如果要进行判断代码会非常冗余

```js
<script type="text/x-template" id="anchored-heading-template">
  <h1 v-if="level === 1">
    <slot></slot>
  </h1>
  <h2 v-else-if="level === 2">
    <slot></slot>
  </h2>
  <h3 v-else-if="level === 3">
    <slot></slot>
  </h3>
  <h4 v-else-if="level === 4">
    <slot></slot>
  </h4>
</script>
```

利用render函数的方式,只需要通过props接收的属性去生成指定的插槽,明显比用template方式要便捷

```js
//这是在局部的组件生成
Vue.component('anchored-heading', {
  render: function (createElement) {
    return createElement(
      'h' + this.level,   // 标签名称
      this.$slots.default // 子节点数组
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
```

**4.在项目中template和render使用的地方**

这是第一种 方式，使用render函数创建组件，在项目中我们都是入口文件这样使用render函数，和下面方式生成效果一样

```vue
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 这里是vue2 ,通过引入vue文件的方式使用vue，没有使用脚手架 -->
    <script src="./vue.js">

    </script>
</head>
<body>
<!-- 准备好一个容器，这个容器的类名可以自定义 -->
<div id="root">

</div>

<script type="text/javascript">
   
    let Cpn = {
        template:`<h2>{{message}}</h2>`,
        data(){
            return {
                message:"我是组件"
            }
        },
    }
//创造vue实例，利用render函数方式使用vue
    new Vue({
        el: '#root',
        //在项目中我们都是缩写 render:h=>h(Cpn)   其实是一样效果这个h其实就是这里的createElement，只不过参数名不一样而已，都是render函数的参数
        render:function (createElement) {
            //2.使用组件
            return createElement(Cpn)
        }
    })

</script>

</body>

</html>
```

这是第二种方式，使用template模板实例化组件,我们在项目中除了入口文件都是以这种方式实例化vue

```vue
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 这里是vue2 ,通过引入vue文件的方式使用vue，没有使用脚手架 -->
    <script src="./vue.js">

    </script>
</head>

<body>
<!-- 准备好一个容器 -->
<div id="root">
    //此处template也可以如下写在vue实例上,效果是一摸一样的
    <template>
        <h2>{{message}}</h2>
    </template>
</div>

<script type="text/javascript">
    // 创建vue实例
    new Vue({
        //el用于指定当前vue实例为那个容器服务 值通常为css选择器字符串
        el: '#root',  
        //data中用于存储数据 数据提供给el所指定的容器去使用 值我们暂时先写成一个对象
        data: {
            message:'我是一个组件'
        },
        // template:'<h2>{{message}}</h2>'
    })
</script>

</body>

</html>
```

#### 31.history和hash路由模式

history

1.地址干净,美观

2.兼容性比hash略差

3.应用部署会出现404的情况,需要后端解决

hash

1.地址中带有#号,不美观

2.兼容性比较好

3.若将地址通过第三方手机app分享,若app校验严格,地址会被标记不合法

**hash路由的原理**

hash是url中hash(#)及后面的那部分,常用锚点在页面内进行导航,改变url中的hash部分不会引起页面刷新,通过hashchange事件监听url的变化,改变url的方式只有这几种,通过浏览器前进或后退改变url,通过<a>标签改变url,通过window.location改变url.这几种情况改变url都会触发hashchange事件;

**history原理**

history提供了pushState和replaceState两个方法,这两个方法改变url的path部分不会引起页面刷新,history提供类似hashchange事件的popstate事件,但popstate事件有所不同,通过浏览器前进后退改变url时会触发popstate事件,通过pushState/replactstate或<a>标签的点击事件来检测url变化,所以监听url变化可以实现,只是没有hashchange那么方便

#### 32.前端页面性能如何优化(和首屏优化类似)

1.减少http请求,可以利用节流防抖的方式

2.善用http缓存,不重复加载相同的资源

3.静态资源我们可以使用cdn分布式网络获取

4.使用树摇删除不需要的代码,在webpack的插件哪里配置

5.使用code-split将代码分割成多个js文件,使得单个文件体积减小

6.利用import懒加载路由,懒加载图片,使用精灵图

7.使用webpack压缩js和css文件

8.合理使用webworker

### 计网相关知识

#### 1.**常见http状态码**	

100，接受的请求正在处理，信息类状态码

200(成功)服务器已成功处理了请求。

3xx(重定向)表示要完成请求，需要进一步操作。通常这些状态代码用来重定向。
301，永久性重定向，表示资源已被分配了新的 URL
302，临时性重定向，表示资源临时被分配了新的 URL
303，表示资源存在另一个URL，用GET方法获取资源
304，(未修改)自从上次请求后，请求网页未修改过。服务器返回此响应时，不会返回网页内容，而是从缓存拿到网页内容

4xx(请求错误)这些状态码表示请求可能出错，妨碍了服务器的处理
400(错误请求)服务器不理解请求的语法
401（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
403(禁止)服务器拒绝请求
404(未找到)服务器找不到请求网页

5xx(服务器错误)这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求的错误
500，(服务器内部错误)服务器遇到错误，无法完成请求
503，表示服务器处于停机维护或超负载，无法处理请求，通常这只是暂时状态

#### 2.Http和Https区别（高频）

1.`HTTP` 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2.`HTTP` 标准端口是80 ，而 HTTPS 的标准端口是443
5.`HTTP` 是超文本传输协议，信息是明文传输，无法加密，而HTTPS 是具有安全性ssl加密传输协议，安全性高于HTTP协议。
6.`HTTP`无需证书，是免费的，而HTTPS 需要CA机构颁发的SSL证书，一般免费证书少，因而需要一定费用。

#### 3.TCP UDP 区别

1.`TCP`向上层提供面向连接的可靠传输服务，使用流量控制和拥塞控制 ，需要通过三次握手建立连接，四次挥手释放连接；`UDP`向上层提供无连接不可靠传输服务，不使用流量控制和拥塞控制，无需建立连接。

2.tcp支持一对一，一对多，多对一和多对多交互通信；udp只支持是一对一通信

3.对数据准确性要求高，速度可以相对较慢的，比如文件传输可以选用`TCP`；虽然 `UDP` 并没有 `TCP` 传输来的准确，但是也能在很多实时性要求高的地方，比如适用于实时应用（IP电话、视频会议、直播等）。

#### 4.GET和POST区别（高频）

1.GET在浏览器回退不会再次请求，POST会再次提交请求
2.GET请求会被浏览器主动缓存，POST不会，要手动设置
3.GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会
4.GET请求在URL中传送的参数是有长度限制的，所以不适合传递大量数据，而POST没有限制
5.GET请求的数据直接暴露在了url里，POST放在Request body请求体中，所以GET请求不安全，POST请求更安全
6.用法不同，私密性的信息请求使用post（如注册、登陆），查询信息使用get。



#### 5.三次握手和四次挥手

https://blog.csdn.net/CC_Together/article/details/105575364



![image-20240306113921046](assets/image-20240306113921046.png)

![image-20240306172910722](assets/image-20240306172910722.png)

三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常。

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。

**第一次握手：**

客户端主动向服务端发送请求建立连接的报文（SYN=1，seq=x），并将自己初始序列号seq=x传递给服务端，此时客户端进入 `SYN_SENT` 同步已发送状态.

SYN = 1 表示请求连接，seq = x 表示起始序列号，通常默认为1

**第二次握手**：

服务端收到客户端的SYN报文之后，会以自己的 SYN 报文作为应答SYN=1，同时会把客户端的 初始序列号seq + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，并且也是指定了自己的初始化序列号 seq=y并进入 `SYN_RCVD` 同步已收到状态。（SYN=1, ACK=1, seq=y, ack=x+1）

**第三次握手：（ACK=1 ack=y+1 seq=x+1）**

客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 seq + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 建立连接状态。服务器收到 ACK确认 报文之后，也处于 ESTABLISHED 建立连接状态，此时，双方已建立起了连接。

![image-20240306172926691](assets/image-20240306172926691.png)

第一次挥手：（FIN=1 seq=u ）

客户端发送请求释放连接的报文FIN=1，以及初始序列号seq=u给客户端，并且停止在客户端到服务端方向上发送数据，也就是关闭了TCP连接，但是客户端仍然能接收从服务端传输过来的数据。客户端进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

第二次挥手：

服务端收到客户端发送连接释放报文，立即发出确认报文，（ACK=1，seq=v，ack=u+1）表示接收到客户端发送的释放连接的请求，并进入关闭等待状态。

第三次挥手：

当服务器做好了**释放**服务器端到客户端方向上的连接准备，也就是服务端没有数据需要传输给客户端了，再次向客户端发出**连接释放报文**（FIN=1，ACK=1，seq=w，ack=u+1），客户端进入LAST_ACK最后确认状态。

第四次挥手：

客户端收到 FIN 连接释放报文段之后，发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要等待2MSL ( 最大报文生存时间) 后再断开连接以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就关闭TCP连接，处于 CLOSED 状态。

**为什么不采用两次握手**

> 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

> 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。**单词服务器此时并不能确认客户端的接收能力是否正常，**所以需要服务器再发一次确认包，这样服务器就知道客户端的接收能力是正常的了

> 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。



**为什么挥手需要采用四次**

因为当第一次挥手服务端收到客户端发来的请求释放连接报文时，此时可能并不能立即释放连接，因为此时可能服务端还有资源需要向客户端传输，所以只能先进行第二次挥手发一个ack的确认报文告诉客户端我收到了你的请求释放连接报文，等到没有资源需要向客户端传输了，服务端就进行第三次挥手发送请求连接释放报文，然后客户端就要进行第四次挥手告诉服务端我收到了你的请求释放报文，释放连接，所以需要四次挥手

**为什么客户端在TIME-WAIT阶段要等2MSL?**

主要目的是确认服务器端是否收到客户端发出的最终ACK确认报文。
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是：一段TCP报文在传输过程中的最大生命周期。2MSL即是一个发送和一个回复所需的最大时间。

服务端如果在1MSL内没有收到客户端发出的最终ACK确认报文（说明最终确认报文丢失了），就会再次向客户端发出FIN报文。

如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时。

所以，客户端要经历时长为2MSLL的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因。




#### 6.输网址（url）到页面加载的全过程

**1.在浏览器中输入URL**

用户在输入后浏览器主进程会先判断用户输入的是URL还是关键字,如果是URL就交给我们网络进程了,如果是关键字就会调用我们默认的搜索引擎去合成一个带有搜索关键字的URL.

**2.查找缓存**

浏览器先查看浏览器缓存->系统缓存->路由缓存中是否有该地址的网址页面,如果有则显示页面的内容,如果没有则进行下一步

其中:

浏览器缓存指:浏览器会记录DNS一段时间,因此,只是第一个地方解析DNS请求

操作系统缓存:如果在浏览器缓存中不包含这个记录,则会使系统调用操作系统,获取操作系统的记录(保存最近的DNS查询缓存)

路由器缓存:当上述两个步骤均不能成功获取到DNS记录的时候,会继续搜索路由器缓存

ISP缓存:若上述均失败,继续向ISP搜索

**3.DNS域名解析**

本地查找没有找到缓存这个资源,浏览器向DNS服务器发起请求,会进行DNS解析，解析该URL中的域名对应的IP地址。DNS实际上就是域名和IP相互对应的数据库,因为IP地址难以记忆,而机器相互只认识IP地址,于是人们发明了域名,让域名和IP一一对应,它们之间的转换工作我们称之为DNS域名解析	

**4.建立TCP连接**

解析出IP地址后，根据IP地址和默认80端口，通过三次握手和服务器建立TCP连接

**5.发起HTTP请求**

浏览器发起获取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器

**6.服务器响应请求并返回结果**

服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器

**7.关闭TCP连接**

通过四次挥手释放TCP连接； 前 两 次挥手用于关闭一个方向的数据通道，后两次挥手用于关闭另外一个方向的数据通道。

**8.浏览器渲染**
客户端（浏览器）解析HTML内容并渲染出来，解析流程为：

构建DOM树：词法分析然后解析成DOM树（dom tree），dom树是由dom元素及属性节点组成，树的根节点是document对象

构建CSS规则树：生成CSS规则树（CSS Rule Tree）

构建render树：浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）

布局（Layout）：计算出每个节点在屏幕中的位置

绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。

**9.JS引擎解析过程：**
调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。

  加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译

预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。

解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。如果是基本数据类型就直接把值放在变量的存储空间栈中，如果是引用数据类型就把指针放入到栈中，指向变量的存储空间，值存在堆中。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。



#### 7.浏览器缓存机制

缓存的标识存在优先级是因为低优先级的那两个标识是http1提出的，而优先级高的是http1.1提出的

https://blog.csdn.net/qq_39903567/article/details/115281234

浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中

![image-20240307143718474](assets/image-20240307143718474.png)

**1.强制缓存**

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：

   ![image-20240307143845309](assets/image-20240307143845309.png)

2.存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图

![image-20240307143936798](assets/image-20240307143936798.png)

3.存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图

![image-20240307143919402](assets/image-20240307143919402.png)

控制强制缓存的字段分别是Expires（到期）和Cache-Control中的max-age，其中Cache-Control优先级比Expires高。主要区别在于前者是绝对时间，如果服务器和客户端处于不同时区可能就会产生误差；而后者属于相对时间。

1.2 Cache-Control
在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：

public：所有内容都将被缓存（客户端和代理服务器都可缓存）
private：所有内容只有客户端可以缓存，Cache-Control的默认取值
no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

**2.协商缓存**

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

1. 协商缓存生效，返回304，如下

![image-20240307150545872](assets/image-20240307150545872.png)

1. 协商缓存失效，返回200和请求结果结果，如下

   

   ![image-20240307150757639](assets/image-20240307150757639.png)

协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，根据这个If-Modified-Since的字段值与现在该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。

Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。

#### 8.http1，http1.1，http2的区别

`HTTP 1.0` 的特点：

1.不支持持久连接，每个请求获取到响应之后会直接关闭tcp连接，下一个请求需要重新开启一个新的tcp连接，增大了网络开销，而且可能造成队头阻塞，因为如果前一个请求因为某些原因被阻塞，那么后面请求都无法发送

2.不支持请求管道化，即客户端需要等待前一个请求的响应才能发送下一个请求。这里和不支持持久连接不冲突

3.无状态协议，服务器不会保留关于客户端的状态信息。



HTTP 1.1相比HTTP 1.0

1.支持持久连接，就是在请求时增加请求头 `Connection: keep-alive`，这样便允许后续客户端再次请求时允许复用之前的 TCP 连接（但是应该是要上一个请求结束，才会执行下一个请求，还是需要排队的）、	

2.支持请求管道化，基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序，所以依然会导致阻塞，没有解决队头阻塞的问题，因此处于各方面考虑，浏览器默认是关闭管道化的。

3.加入了缓存处理（强缓存和协商缓存），通过例如cache-conrtol和Etag来控制缓存的时效性和更新；

4.引入了虚拟主机的概念，使得多个域名可以共享同一个IP地址。这样可以在同一个服务器上托管多个网站，提高服务器资源的利用率。

HTTP 2相比HTTP 1.x（核心是进一步优化了传输效率）

1. `多路复用`：HTTP 2.0引入了多路复用技术，允许在同一个TCP连接上同时发送多个请求和响应。这样可以避免HTTP 1.x中的队头阻塞问题，提高请求的并发处理能力，加快页面加载速度。
2. `二进制格式`：HTTP 2.0使用二进制格式传输数据，取代了了HTTP 1.x解析基于文本（好像就是基于报文）。二进制格式的解析效率更高，减少了数据传输的大小，节省了带宽和时间。
3. 服务器推送，服务器可以主动向客户端推送资源，而不需要客户端明确请求，提高了性能和效率
4. 头部压缩，通过字典的形式，将头部中常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量

#### 9.常见http请求响应头

https://blog.csdn.net/HHYZBC/article/details/124297104

请求报文：由请求行、请求头、[请求体](https://so.csdn.net/so/search?q=请求体&spm=1001.2101.3001.7020)组成。

请求行：由请求方式和[HTTP协议](https://so.csdn.net/so/search?q=HTTP协议&spm=1001.2101.3001.7020)和版本组成，如：GET / HTTP/1.1

**请求头：**

1.Accept：请求报头域，用于指定客户端可接受哪些类型的信息，Accept: text/html ，代表浏览器可以接受服务器回发的类型为 text/html；

2.Accept-Language：指定客户端可接受的语言类型，如Accept-Language:zh-CN,zh;q=0.9；

3.Accept-Encoding：浏览器申明自己接收的编码方法，Accept-Encoding: gzip, deflate ：通常指定压缩方法，是否支持压缩，支持什么压缩方法为gzip，deflate，（注意：这不是只字符编码）

4.Host（发送请求时，该报头域是必需的）：如Host:www.baidu.com 请求报头域主要用于指定被请求资源的域名和端口号，它通常从HTTP URL中提取出来的，这里就是请求的地址是百度；

5.Referer，如Referer:https://www.baidu.com/?tn=62095104_8_oem_dg 当浏览器向服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

6.Cache-Control

Cache-Control:private，默认为private 响应只能够作为私有的缓存，不能再用户间共享

Cache-Control:public ，响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.**Cache-Control:must-revalidate 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。

Cache-Control:no-cache ，响应不会被缓存,而是实时向服务器端请求资源。

Cache-Control:max-age=10 ，设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。

Cache-Control:no-store ，在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。

**`no-store` 和 `no-cache` 的区别**

1. `no-store`：
`no-store` 指令表示在任何情况下都不应该对请求或响应进行缓存。这意味着在客户端和服务器端都不能缓存响应，每次请求都需要从服务器重新获取资源。这通常用于处理包含敏感信息的页面，例如银行交易、个人资料等。
2. `no-cache`：
`no-cache` 指令表示在使用缓存之前必须先与服务器确认其有效性。这意味着客户端可以缓存响应，但在下一次请求时，必须先向服务器发送一个验证请求，询问该响应是否已更新。如果服务器确认缓存仍然有效，则可以使用缓存，否则需要从服务器重新获取资源。

总之，`no-store` 是绝对禁止缓存的，而 `no-cache` 是允许缓存，但在使用缓存之前必须先进行验证。

**7.Content-Type**：告诉服务器我们发送的请求信息是哪种格式的，不合适的Content-Type可能导致服务端无法正确接收我们的参数。

![image-20240324115324611](assets/image-20240324115324611.png)

8.User-Agent：简称 UA ，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本 浏览器及版本等信息 。

9.cookie：

#### 10.安全问题 ：CSRF 和 XSS 攻击？

`XSS`(`Cross-Site Scripting`，**跨站脚本攻击**)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者浏览该网站时就会执行这些嵌入的恶意代码，这些脚本可以读取 `cookie，session tokens`，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。

**XSS避免方式：**

1. `url`参数使用`encodeURIComponent`方法转义

   ```js
   function encodeForURL(str){
     return encodeURIComponent(str);
   };
   ```

2. 尽量不使用`InnerHtml`插入`HTML`内容

3. 使用特殊符号、标签转义符。

   ```js
   //将html标签进行转义，将html的属性进行转义，因为属性都是用单引号或双引号包裹，最终在浏览器输出的结果是一样的
   var escapeHtmlProperty = function(str){
       if(!str) return '';
       str = str.replace(/&/g,'&amp;');
       str = str.replace(/</g,'&lt;');
       str = str.replace(/>/g,'&gt;');
       str = str.replace(/"/g,'&quto;');
       str = str.replace(/'/g,'&#39;');
       return str;
   }
   escapeHtml(content);
   
   
   ```

   

`CSRF`（`Cross-site request forgery`）**跨站请求伪造**：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

**CSRF避免方式：**

 1.**Token 验证：（用的最多）**

 1.1服务器发送给客户端一个 加密后的token ；

 1.2客户端提交的表单中需要携带这个 token 。

 1.3服务器会检验这个token是否正确，如果这个 token 不正确，那么服务器拒绝这个请求。

#### 11.单点登录（上次面试问到过，深圳编办系统多系统只使用单个登录页登录，我没回答上来）

https://blog.csdn.net/qq_41595452/article/details/122066984

cookie和redies实现：

用cookie作为媒介存放用户凭证。 用户登录系统之后，会返回一个加密的cookie，当用户访问子应用的时候会带上这个cookie，授权以解密cookie并进行校验，校验通过后即可登录当前用户。
① 系统会先将用户的登录信息存入 redis中，其在 redis 的 key 值是生成的唯一值 （可以包含 IP、用户 id、UUID等值），value 值存放用户的登录信息。

② 然后系统会将这名用户在 redis 中的 key 值存入该用户的 cookie 中，用户每次访问任意子系统时都会带着这个 cookie。

③ 用户在访问其他子系统发送请求时，都会带着客户端的 cookie 进行请求，而客户端的 cookie 已经存入了该用户在 redis 中的 key 值，这样其他模块在处理用户的请求时，可以先获取用户 cookie中的 key 值，然后拿着这个 key 值到 redis 中进行查询，如果在 redis 中能查询到该用户相应的登录信息，就说明该用户已登录，就不需要用户进行重复登录了。

![img](assets/049f6492889bd943188b35161c8cdac1.png)

#### 12.cookies,sessionStorage,localstorage区别

相同点：都存储在客户端
不同点：1.存储大小

· cookie数据大小不能超过4k。

· sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

2.有效时间

· localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；

· sessionStorage  数据在当前浏览器窗口关闭后自动删除。

· cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

3. 数据与服务器之间的交互方式

· cookie的数据会随着http请求自动的传递到服务器，服务器端也可以写cookie到客户端

· sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

4.后两者有建议的增删改查方法，而cookies需要封装,注意,在存储引用数据类型的时候需要用JSON.stringify()转义,获取再用JSON.parse()来获取, 修改的话直接用setItem里面放新数据就可以了

#### 13.关于cookie的细节

https://blog.csdn.net/qq_39834073/article/details/107808959

在前端，可以使用JavaScript通过`document.cookie`来设置和操作Cookie。domin也可在这里面设置

cookie的属性：

如图![image-20240413124923635](assets/image-20240413124923635.png)

1.Name和Value

**Name**和**Value**是一个键值对。**Name**是Cookie的名称，Cookie一旦创建，名称便不可更改，一般名称不区分大小写；**Value**是该名称对应的Cookie的值，如果值为[Unicode](https://so.csdn.net/so/search?q=Unicode&spm=1001.2101.3001.7020)字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码；

2.Domain
Domain决定Cookie在哪个域是有效的，也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Doamin设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(".")开始。
3.Path
Path是Cookie的有效路径，和Domain类似，也对子路径生效，如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 /b/,而Cookie2的Path为 /b/c/,则在a.com/b页面时只可以访问Cookie1，在a.com/b/c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“/”结尾。
4.Expires/Max-age
Expires和Max-age均为Cookie的有效期，Expires是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是客户端的时间，是个绝对时间，可能会受到时区的影响，Max-age则是一个绝对时间，不受时区影响，两者都存在时Max-age优先级更高，若不设置cookie的有效期则默认页面关闭时删除该Cookie。
Max-age也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0或-1，cookie会直接过期

![image-20240415173703491](assets/image-20240415173703491.png)

5.Size
Szie是此Cookie的大小。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。各个浏览器对Cookie的最大值和最大数目有不同的限制，整理为下表(数据来源网络，未测试)：

![image-20240413125341235](assets/image-20240413125341235.png)

6.HttpOnly

**HttpOnly**值为 *true* 或 *false*,若设置为*true*，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。可以防止xss跨站脚本攻击。

7.Secure

**Secure**为Cookie的安全属性，若设置为*true*，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。

8.SameSite
SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：

8.1Strict
Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie

8.2Lax
Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

8.3None
网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。
9.Priority

优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。
在360极速浏览器和FireFox中，不存在**Priority**属性，不清楚在此类浏览器中设置该属性后是否生效。

**实现cookie跨子域，但是不能跨到其他域**

![image-20240325220910034](assets/image-20240325220910034.png)

**HttpOnly 标志——保护 Cookie 免受 XSS，在后端响应头Set-Cookie上这样加上httpOnly，**

Set-Cookie: sessionid=QmFieWxvbiA1; HttpOnly；大多数XSS攻击都是针对会话cookie的盗窃。后端服务器可以通过在其创建的cookie上设置HttpOnly标志来帮助缓解此问题，这表明该cookie在客户端上不可访问。如果支持HttpOnly的浏览器检测到包含HttpOnly标志的cookie，并且客户端脚本代码尝试读取该cookie，则浏览器将返回一个空字符串作为结果。这会通过阻止恶意代码(通常是XSS)将数据发送到攻击者的网站来使攻击失败。

**跨域请求的cookie携带问题**    例如a.com和b.com之间，这不属于跨子域

在站点A下面访问B域名的接口，那么这是一个跨域请求，如果不做处理，此时这个请求就跨域了，所以我们需要需要先设置跨域，可以使用代理跨域的方式实现跨域，解决跨域以后，如何允许跨域请求携带cookie，此时需要设置axios的withcredentials的属性为true，告诉浏览器在访问B网站时，将B网站的cookie带上，此时光前端设置还不行，还需要后端在响应头中添加 allow-withcredentials = true,这样就可以保证跨域请求也可以携带cookie。

![image-20240418142642096](assets/image-20240418142642096.png)



#### 14.浏览器的并发限制

就是同时发起http请求是存在上限的，超过限制的http请求会在前面请求没有响应回来之前进入队列进行排队.比如先存在一百个http请求，浏览器并发限制时50个，那么在前五十个请求都没有响应之前，第51到100的请求都会在队列排队。

**并发**是指在**一个时间段**内有多个进程在执行。**并行**指的是在**同一时刻**有多个进程在同时执行。 **高并发**是使用技术手段使系统可以并行处理很多请求。

解决浏览器并发限制办法：

1.将资源分散到不同域名：浏览器并发连接数限制只是针对同一域名，将资源分散到不同的域名下，即可实现并发数的扩展，例如一个域名是10个，两个域名就是20个并发了，注意：资源地址的端口号不同也会被视为不同域名。

2.减少网络请求
2.1.配置304请求（也就是多利用浏览器的缓存），提高请求速度 (后端配置)
2.2图标、css、js合并，减少http请求数
2.3使用缓存，使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求
2.4不使用CSS的【@import】，它会造成额外的请求
2.5vue使用动态路由，实现按需导入js，减少http请求数

#### 15.token的四个存储位置和区别

这篇文章讲的已经比较清晰了以及token使用的具体流程https://blog.csdn.net/m0_64346035/article/details/125239403



#### 16.常见的http请求方式	

GET：用于获取资源，一般用于读取数据。特点是请求参数在URL中，[请求体](https://so.csdn.net/so/search?q=请求体&spm=1001.2101.3001.7020)为空。

POST：用于提交数据，一般用于新增数据。特点是请求参数在请求体中。

PUT：用于更新数据，一般用于修改数据。特点是请求参数在请求体中，但会替换原有数据。

DELETE：用于删除数据，一般用于删除数据。特点是请求参数在URL中，请求体为空。

HEAD：和GET请求相同，请求页面的头部信息与GET 方法请求时返回的一致，不同点在于head不获取响应体信息，只返回头部信息。

OPTIONS：用于获取当前URL所支持的HTTP方法。

TRACE：用于追踪HTTP请求的路径。

CONNECT：用于将HTTP请求转换为透明的TCP/IP连接。

为什么post请求已经可以完成对数据的增删改查，还需要提出put，delete等其他请求呢？

1.幂等性（就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用）：post请求通常不是幂等的，如果POST请求包含了对资源的修改操作，多次执行可能会导致相同的操作被执行多次。这可能会导致资源状态的不一致或产生意外结果，如可能在数据库重复创建相同的资源或多次修改相同的资源。而put和delete请求是幂等的，多次执行相同的PUT请求对服务器状态没有额外影响，因为它是整体替换。

2.使用put，delete请求有助于提高api的语义化

3.PUT和DELETE方法要求客户端提供完整的资源数据，这种明确的资源定位可以确保对特定资源的操作被正确地执行，而不会对其他资源产生意外的影响。而post请求不要求客户端提供完整的资源数据，数据通常包含在请求体中。服务器根据请求执行相应的处理，可能是创建新资源或更新部分资源。



#### 17.自己开发页面到别人哪里白屏了怎么办（了解一下）

1. **网络问题**：确保用户的网络连接良好，没有网络问题导致页面无法加载。可以让用户尝试刷新页面或者检查其网络连接。
2. **浏览器兼容性问题**：不同的浏览器可能对同一份代码的解析存在差异，导致页面在某些浏览器上出现白屏。建议让用户尝试使用其他浏览器访问页面，或者检查页面代码，确保没有使用到特定浏览器不支持的特性。
3. **JavaScript 错误**：页面中的 JavaScript 错误可能导致页面无法正常加载和渲染。可以让用户尝试在浏览器开发者工具中查看控制台（Console）是否有错误信息，然后针对错误信息进行修复。
4. **服务器问题**：如果页面依赖于后端服务，可能是后端服务出现了问题导致页面无法加载。可以检查后端服务的运行状态，并确保服务正常运行。
5. **资源加载问题**：可能是页面中引用的某些资源（如 CSS、JavaScript、图片等）加载失败或者路径错误导致页面无法正常显示。可以检查页面中引用的资源路径是否正确，并确保这些资源能够被正常加载。
6. **缓存问题**：浏览器缓存可能导致页面内容没有及时更新。可以让用户尝试清除浏览器缓存，然后重新加载页面。



#### 18.除cookie以外其他可以标识用户的方法

1. **Session（会话）**：服务器端可以通过会话来跟踪用户的状态。当用户访问网站时，服务器会创建一个唯一的会话ID，并将其存储在服务器端。然后，服务器将这个会话ID发送给客户端，并在后续的请求中通过这个会话ID来识别用户。虽然会话ID通常是通过cookie来传递的，但也可以在URL中或者通过其他的手段传递。
2. **URL 重写**：在URL中包含用户标识信息，这样服务器就可以根据URL中的信息来识别用户。这种方法通常需要在每个链接和重定向中都包含用户标识信息，比较繁琐，而且可能会暴露用户信息。
3. **用户代理标识**：服务器可以根据用户的用户代理（User-Agent）标识来识别用户。每个浏览器和设备都有一个唯一的用户代理标识，可以用来识别用户的设备和浏览器类型。然而，用户代理标识可以被篡改，而且不适合用于长期跟踪用户。
4. **IP 地址**：服务器可以根据用户的IP地址来识别用户。然而，由于许多用户共享相同的IP地址（例如在公司或学校内部网络中），因此使用IP地址来识别用户可能不够精确，而且用户的IP地址也可能会发生变化。

#### 19.cdn（可以提高用户访问资源速度，可以作为优化）

这篇文章讲的很好https://blog.csdn.net/u012060033/article/details/125065781

1.CDN`全称叫做`Content Delivery Network`，中文叫`内容分发网络，就是我们可以通过例如阿里的cdn服务，将我们的静态资源，比如图片，视频，css，javascript等等部署到服务器上，那么阿里在各个地方的服务器上就都存在我部署的静态资源了，用户使用某个域名来访问静态资源时（这个域名在阿里`CDN`服务中叫做“加速域名”），比如这个域名为`image.baidu.com`，它对应一个`CNAME`，叫做`cdn.ali.com`，那么普通`DNS`服务器（区别`CDN`专用`DNS`服务器）在解析`image.baidu.com`时，会先解析成`cdn.ali.com`，普通`DNS`服务器发现该域名对应的也是一个`DNS`服务器，那么会将域名解析工作转交给该`DNS`服务器，该`DNS`服务器就是`CDN`专用`DNS`服务器。`CDN`专用`DNS`服务器对`cdn.ali.com`进行解析，然后依据服务器上记录的所有`CDN`服务器地址信息，选出一个离用户最近的一个`CDN`服务器地址，并返回给用户，用户即可访问离自己最近的一台`CDN`服务器，提高了网络请求的速度



2.网络请求原理原析：当我们使用域名访问一个网站时，实际上就是讲请求包（http请求）通过网络传输给服务器，如我们访问www.baidu.com时，我们首先利用dns服务器解析出这个域名对应的ip地址，然后将`Http`请求包通过网络路由到`IP`地址所对应的服务器。

3.域名解析又有两种情况：

3.1.如果域名直接对应了ip地址，就将这个ip地址拿到返回给请求者，请求者再通过http请求到这个ip地址对应的服务器

![image-20240414123133059](assets/image-20240414123133059.png)

3.2.如果这个域名存在别名，比如www.baidu.com存在另外一个别名的域名 test.baidu.com,这个别名我们称之为cname那么我们在dns域名解析的时候首先将这个域名解析成这个域名的别名，然后找到这个别名对应的ip地址返回给请求者（这里前提是这个别名没有别名了）![image-20240414123141494](assets/image-20240414123141494.png)



在有`CNAME`的情况下，我们可以发现，`CNAME`实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是`CDN`实现的关键。

4.cdn原理：cdn是为了改善网络质量，说白就是提高访问速度，

假设百度网站现在只有一台服务器，现在有一个人在上海访问百度，如果该服务器也在上海，那么通常来说访问比较快，如果该服务器在拉萨，那么相对而言访问就比较慢了。那么这个问题的根本原因是网络传输是依赖于网线的，网线越长，那么时间肯定就越久。

那么怎么解决这个问题呢？其实思路很简单，百度在全国各地都部署一模一样的服务器就行了，当我们在新疆访问百度的时候，就使用百度在新疆的服务器，当我们在上海访问百度就使用在百度的服务器，专业一点叫冗余。

思路很简单，但实现还是比较麻烦的，服务器上的资源分为两种：`静态资源`与`动态资源`

- `静态资源`：这种资源通常是很少变动的，比如图片，视频，css，javascript等等
- `动态资源`：这种资源不同用户不同时刻访问通常是不一样的，比如ftl，jsp等等。

那么如果百度要在全国各地都部署服务器，如果说每个服务器上都有相同的动态资源，那么可能还需要配置相应的数据库，因为动态资源所记录的信息通常会存储在数据库中，那么这就涉及到了数据同步等等问题，这会导致成本很高，这种做法专业一点其实就是集群，主要是成本太高。

那么我们折中的办法就是在每个服务器上只部署静态资源，因为静态资源一般不涉及数据库，且也能提高用户响应速度，这就是cnd想要实现的目的。

还有后续的东西直接看上面链接的文章



#### 20.五层网络模型

讲的还行，大致知道每一层要干什么就行https://juejin.cn/post/7210691957790081081

这篇没看，可以当作补充，上面一些理论上东西没讲到https://juejin.cn/post/6844904029823172622



### 关于ts

看typescript和class类这个文件夹中的md,和里面我自己写的一些demo代码加深理解

#### 1.继承时候一直为何用到super

```typescript
//如下子类和父类都存在相同名称的方法，当然调用的就是子类的，如果子类没有这个方法，调用的就是从父类继承过来的方法
class Animal {
        name: string;
        constructor(name: string) {
            this.name = name;
        }
    //在constructor外的方法就是原型上的方法
        sayHello() {
            console.log('动物在叫~');
            console.log(this)
        }
    }

    class Dog extends Animal{
        age: number;
        constructor(name: string, age: number) {
            // 如果子类也需要constructor创造一些属性，那么这个constructor会覆盖掉从父类继承过来的constructor里的属性，那么就需要使用super在子类中重新调用父类构造函数中的内容，这样name这个属性就可以获取到，不然就获取不到，这就是super的作用
            super(name); // 调用父类的构造函数
            this.age = age;
        }

        sayHello() {
            // 在普通方法中 super就表示父类的原型对象；在static静态方法中就表示父类
            // super.sayHello();
            console.log('汪汪汪汪！');
        }

    }

    const dog = new Dog('旺财', 3);
    dog.sayHello();
    console.log(dog.name)
```

#### 2.抽象类

```ts
以abstract开头的类是抽象类，
    *       就是说我们希望Animal这个类只会被用来继承，而禁止他来创建实例对象，我们就把Anmial定义为抽象类
    *       抽象类就是专门用来被继承的类，和其他类没有任何区别，就是不能用来创建实例对象
    *       抽象类中可以添加抽象方法
    *       如果你实例化这个类，会爆出警告
 abstract class Animal {
        name: string;
        constructor(name: string) {
            this.name = name;
        }

        // 定义一个抽象方法
        // 抽象方法使用 abstract开头，没有方法体
        // 抽象方法只能定义在抽象类中，定义了一个子类必须重写的方法，不重写会报错
        // 可以不定义为抽象方法，可有可无
        // abstract sayHello():void;
    }

    class Dog extends Animal{
age:number
        //这个继承过来的name不需要在上面写一次
constructor(name: string,age:number){
super(name)
this.age=age
}
        sayHello() {
            console.log('汪汪汪汪！');
        }

    }

    class Cat extends Animal{
        sayHello() {
            console.log('喵喵喵喵！');
        }

    }

    const dog = new Dog('旺财',18);
    dog.sayHello();
console.log(dog.age)
```

#### 3.泛型和接口和自定义属性

**泛型和接口的区别**:接口使用interface关键字来定义,而泛型使用<>符号来定义,接口主要作用是定义对象或者数组的具体类型,必须要符合定义的类型不然就会报警告,而泛型比接口更灵活,通常用于定义还没有明确使用具体类型的函数或类,如下例子可以看出大致一些区别.

**接口和自定义属性的区别**:两者都可以定义数据的类型,而type使用&符号来实现组合多个类型,而interface使用extends来继承别的接口;type比interface更灵活,interface主要用来定义对象的结构,而type不仅可以定义对象结构,还可以用来定义如元组类型或联合类型;

1.接口(interface)

接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。

```ts
interface Person{
    name: string;
    sayHello():void;
}

class Student implements Person{
    constructor(public name: string) {
    }

    sayHello() {
        console.log('大家好，我是'+this.name);
    }
}
```

2.泛型

定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），我们就可以使用泛型去指定其大致的类型

举个例子：

- ```typescript
  function test(arg: any): any{
  	return arg;
  }
  ```

- 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型

- 使用泛型：

- ```typescript
  function test<T>(arg: T): T{
  	return arg;
  }
  ```

- 这里的```<T>```就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。

- 那么如何使用上边的函数呢？

  - 方式一（直接使用）：

    - ```typescript
      test(10)
      ```

    - 使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式

  - 方式二（指定类型）：

    - ```typescript
      test<number>(10)
      ```

    - 也可以在函数后手动指定泛型

- 可以同时指定多个泛型，泛型间使用逗号隔开：

  - ```typescript
    function test<T, K>(a: T, b: K): K{
        return b;
    }
    
    test<number, string>(10, "hello");
    ```

  - 使用泛型时，完全可以将泛型当成是一个普通的类去使用

- 类中同样可以使用泛型：

  - ```typescript
    class MyClass<T>{
        prop: T;
    
        constructor(prop: T){
            this.prop = prop;
        }
    }
    ```

- 除此之外，也可以对泛型的范围进行约束

  - ```typescript
    interface MyInter{
        length: number;
    }
    
    function test<T extends MyInter>(arg: T): number{
        return arg.length;
    }
    ```

#### 4.ts中的命名空间和模块

1.**模块**

1.1全局模块:

在默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中,在全局变量空间是危险的，因为他会与文件内的代码命名冲突。我们推荐使用下文中将要提到的文件模块

1.2文件模块

文件模块也被称为外部模块。如果在你的 TypeScript 文件的根级别位置含有 import 或者 export，那么它会在这个文件中创建一个本地的作用域,模块在自身的作用域里执行,而不是在全局作用域里,模块里的变量、函数、类等在外部是不可见的，除非将其导出.

```ts
// 此时a，b和默认导出的name可以在其他文件导入使用
// c由于未导出，因此在其他文件导入c时会报错
export const a = 1;
export const b = 2;
const c = 3;
export default { name: 'Tom' }

// 导入
// import { a, b } from './xxx.ts'

```

2.命名空间(我感觉挺鸡肋的,因为export和import就可以完成这个功能)

**2.1定义**:在代码量较大的情况下，为了避免命名空间冲突，可以将相似的函数、类、接口放在命名空间内.

**2.2原理**:命名空间被编译成了一个立即执行函数,函数创建了一个闭包,在闭包中的私有成员,就是未导出成员,导出成员会被挂载在一个全局变量下

命名空间内的对象通过 export 关键字对外暴露，比如我们在一个名叫 `utils.ts` 的文件里声明一个命名空间：

```ts
// utils.ts
namespace Utils {
    export interface IPerson {
        name: string;
        age: number;
    }
}
```

命名空间在别的文件的使用:使用reference标签引入或者import引入都可以

```ts
 //在别的文件中
//引入方法1
import './utils'
//引入方法2
<reference path="utils.ts" />
  //使用方式为命名空间名.   如下的Utils.IPerson  
const me: Utils.IPerson = {
    name: 'funlee',
    age: 18
}
console.log(me); // {name: 'funlee', age: 18}
 
```



### nodejs



### webpack

#### 1.webpack的组成

Webpack 是一个模块打包工具，它的主要组成部分包括(前五项是webpack的核心)：

1. 入口(Entry)：Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入,指定webpack从哪里开始打包。
2. 输出(Output)：在 Webpack 经过一系列处理并得到最终想要的代码后，输出结果，可抽象成输出。
3. Loader：模块加载器，用于把不同格式的文件转换成可以被添加到依赖图中的模块，比如将 SCSS 转换成 CSS，将 TypeScript 转换成 JavaScript 等。**webpack只认识js，json，loader就成了翻译官**
4. Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件，在特定时机做对应的事情。
5. Mode：模式，用于指定构建目标，如 development 或 production，不同模式下会应用不同的构建优化。
6. Browser Compatibility：浏览器兼容性，Webpack 输出结果支持所有符合 ES5 标准的浏览器。
7. DevServer：开发服务器，用于快速原型开发，提供实时重新加载(这一个配置只有在开发模式会使用)。
8. Devtool：源码映射工具，当代码出错时，通过源码映射功能，提供代码错误的精确位置,生产模式配置是找到具体哪一行那一列出错了,如devtool: "source-map"。
9. Optimization：优化项，用于控制如何压缩、分割代码等。

#### 2.开发模式和生产模式区别

最大区别就是生产模式我们是需要打包的,所有我们会在打包上做很多优化,而开发模式我们是不需要打包的,只会在浏览器运行,所以我们必须配置devServer,只有当开发模式测试出没有问题了,我们才会进行打包.

#### 3.webpack性能优化方法

1.js代码压缩

2.css代码压缩

3.html文件代码压缩

4.文件大小压缩

5.图片压缩

6.树摇

7.代码分离

#### 4.wbepack的loader和plugin区别?常用的plugin和loder有哪些?

1.loader,说白了webpack只认识js，json，loader就成了翻译官,将webpack不认识的语言如css,ts,scss,都转换成webpack认识的语言;

常见的loader:   

postcss-loader:当你在 CSS 文件中使用了新的语法或者需要添加浏览器前缀时，`postcss-loader` 会自动将其转换为兼容当前浏览器的 CSS 代码，并进行压缩和优化;

css-loader:它可以将 CSS 代码转换为 CommonJS 模块，从而使得 CSS 代码可以在 JavaScript 中被引用和使用;

style-loader:可以帮助你在 Webpack 构建过程中动态地将 CSS 代码添加到 HTML 页面中，从而实现样式的动态加载和热更新

scss-loader:可以将 SCSS 代码转换为 CSS 代码,然后再利用css-loader转换成可以被js引用的代码,而webpack可以识别js

less-loader

eslint-loader:可以通过配置 `eslint-loader` 来指定如何对 JavaScript 代码进行 lint 检查

```js
  use: [
  //执行顺序，从右至左或从下至上，最先执行less-loader,再执行css-loader，再执行style-loader,一步步进行转化
                            "style-loader",//将js中css通过创建style标签添加到html文件中生效
                            "css-loader",//将css资源编译成commonjs的模块到js中
                            'less-loader',//将less编译成css文件
                        ],
```

2.plugin即插件,是一个扩展器,丰富webpack本身,webpack打包的整个过程,他并不直接操作文件,而是基于事件机制工作,监听webpack打包过程中的某个节点,执行广泛的任务

常见的plugin:

HtmlWebpackPlugin:用于在 Webpack 构建过程中自动生成 HTML 文件。它可以帮助你在 Webpack 构建过程中动态地生成 HTML 文件，并将生成的 JavaScript 和 CSS 文件自动引入到 HTML 文件中，从而实现 HTML 文件的动态生成和自动化管理;

TerserWebpackPlugin:树摇;

CssMinimizerPlugin:压缩css

#### 5.开启热模块的方式(在下面代码中)

热模块,或热更新就是在开发模式先不打包,当你修改了内容,浏览器会实时刷新你修改的内容,方便开发人员测试效果.

#### 6.开启树摇(在下面代码中)

Webpack 中的树摇（Tree Shaking）是一种用于移除 JavaScript 代码中未使用的死代码的技术,通过分析项目的依赖关系，找出未被引用的模块或模块中未被使用的成员，然后在构建过程中将其移除，从而减少最终打包后的代码体积。

#### 7.开启代码分割code-split(在下面代码中)

```js
 //首先引入热模块插件
//npm install webpack-dev-server html-webpack-plugin --save-dev
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path')
module.exports = {
  //入口
  entry: {
    index: './src/index.js',
  },
    //出口
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
    
 // 在开发服务器,正常情况下当开发者修改内容后需要重新打包然后运行才能看到修改后的效果，而配置了热模块之后，npx webpack serve 当你修改内容保存，浏览器会实时刷新你修改的内容，此时并没有打包生成dist文件夹，这就是vue编译代码的原理，此时其实是一直没有打包的，只是让我们测试用，等我们觉得这个代码修改没问题了，然后可以再npm webpack生成新的打包文件dist，这就是所谓的热更新
    devServer: {
        host: "localhost", // 启动服务器域名
        port: "3000", // 启动服务器端口号
        open: true, // 是否自动打开浏览器
        hot: true,//开启HMR(Hot Module Replacement)热模块替换(默认是开启的，开启后当我们只修改了一个文件代码，打包的时候只修改这一个文件，其他文件利用原先的缓存),只有开发环境使用
    },
  plugins: [
      //开启热模块加载
    new HtmlWebpackPlugin({
      title: 'Webpack HMR Demo',
      template: 'src/index.html',
    }),
  ],
  // 模式
    mode: "development",
    //devtool是源码映射工具，当代码出错时，通过源码映射功能，提供代码错误的精确位置
    // 配置sourceMap，帮助我们更准确的找到错误代码未知，生产模式配置是找到具体哪一行那一列出错了
    devtool: "source-map",
    
    //优化项,用于控制如何压缩、分割代码等,这个模块是在生产者模式才有的,因为开发者模式根本就不需要打包,这里为了方便所以这么写
    optimization: {
        // 在这里放置压缩的操作 
        minimizer: [
            // 压缩css
            new CssMinimizerPlugin(),
            // 压缩js,就是树摇
            new TerserWebpackPlugin({
                parallel: threads,//开启多进程和进程数量
            }),
            // 压缩图片
            new ImageMinimizerPlugin({
                minimizer: {
                    implementation: ImageMinimizerPlugin.imageminGenerate,
                    options: {
                        plugins: [
                            ["gifsicle", { interlaced: true }],
                            ["jpegtran", { progressive: true }],
                            ["optipng", { optimizationLevel: 5 }],
                            [
                                "svgo",
                                {
                                    plugins: [
                                        "preset-default",
                                        "prefixIds",
                                        {
                                            name: "sortAttrs",
                                            params: {
                                                xmlnsOrder: "alphabetical",
                                            },
                                        },
                                    ],
                                },
                            ],
                        ],
                    },
                },
            }),
        ],
        // 代码分割配置,可以使得单个文件体积更小,并行加载js速度更快
        // 1.如果我们以后用到了node_modules里面代码，会把用到的在dist里面单独打包成一个js文件
        // 2.如果我们用到了动态导入语法，就是懒加载路由那种写法，也会把引入的文件打包成单独的文件，而不是全部放在main.js里面
        splitChunks: {
            chunks: 'all',
            // 其他配置都用默认值即可
        },
        untimeChurnk: {
            name: (entrypoint) => `runtime~${entrypoint.name}.js`
        }
    },
};
```





### 手搓题

#### 1.上次面试的切换类名（有时间试一下用原生的方式写）还有一个利用正则区分密码难度 有三个等级

```vue
 <button @mouseenter="move1" @mouseleave="leave1">奇数</button>
  <button @mouseenter="move2" @mouseleave="leave2">偶数</button>
  <!-- 此处动态添加class类名的方式是对的 -->
  <!-- <div v-for="(item,index) in 6" style="border: 1px solid red;" class="init" :class="`${'div'+index}`">{{ item }}</div> -->
  <!-- 此处添加多个class类名用如下方式 数组    还有一个麻烦的方法就是写多个class，太麻烦，注意有的需要加冒号 -->
  <div v-for="(item,index) in 6"  :class="['init',index%activeIndex1===0?'active':'',index%activeIndex2===1?'active':'']" >{{ item }}</div>


 data() {
    return {
      activeIndex1:0,
      activeIndex2:0,
    };
  },

 move1(){
      this.activeIndex1=2
    },
    leave1(){
      this.activeIndex1=0
    },
    move2(){
   this.activeIndex2=2
    
    },
    leave2(){
      this.activeIndex2=0
    },

<style>
    .init{
  border: 1px solid red;
}

.active{
  /* 这个地方由于切换属性用的行内样式 权重比这里高 所以必须加important */
  /* border: 10px solid black !important; */
  border: 10px solid black !important;
  font-weight: 600;
  color: yellow;
}

</style>
```

#### 2.数组取重（我这里的取重是两个不同数组取重）

```js
 //数组取重  这里有一个问题 当你某个数组内本身就有重复的属性值的时候，取出来的会有两个重复的，我觉得解决办法可以先将取重的数组去重，在去取重
        const arr1 = [1, 2, 3, 4, 5]
        const arr2 = [2, 6, 3, 2]
        let arr3 = []
        //方法1
        // arr2.forEach((item, index) => {
        //     if (arr1.includes(item)) {
        //         arr3.push(item)
        //     }
        // })
        // console.log(arr3) //[2, 3, 2]

        //方法2 返回true和返回一个判断为true，这两种写法都是可以的
        arr3 = arr1.filter((item, index) => {
            // return arr2.includes(item)
            if (arr2.includes(item)) {
                //这个return值我们写任意的通过判断为true的值都可以，如 return item ；return 1，因为这个return true只是告诉我们你遍历到这个元素是符合要求的，返回出去，并不是将
                // return 后面的值返回出去，这里我们需要注意
                return true
            }
        })

//方法3 双重for循环也可以
  for (let i = 0; i < arr1.length; i++) {
            for (let j = 0; j < arr2.length; j++) {
                if (arr1[i] == arr2[j]) {
                    arr3.push(arr1[i])
                    //此处的break作用避免如果arr2存在第二个属性和arr1[i]相同，将第二个元素也添加给arr3，但是无法避免如果arr1存在两个相同的元素这种情况
                    break
                }
            }
        }


//方法4 是个错误方法，我放在这里是让我能明白，map和filter的区别
          arr3 = arr1.map((item, index) => {
            // 这一步是错的 因为map返回的和filter不一样，filter是判断为true的元素返回出去，而map返回的直接就是那个你处理过的元素
            // return arr2.includes(item)
            //返回的结果为[undefined, 2, 3, undefined, undefined]，说明无法用map实现取重，因为不符合条件的判断一样会返回出去，值为undefined
            if (arr2.indexOf(item) != -1) {
                return item
            }
        })
        console.log(arr3)
```

#### 3.单个数组中取重

```js
let arr1 = [2, 6, 3, 2, 10, 5, 1, 2, 3, 1, 2, 3, 11]

//方法1 这个方法特别巧妙，就是判断某一个元素在这个数组中首尾存在下标是否不一致，不一致就说明这个元素存在两个或以上，然后为了防止取到的数组中有多个这个元素，在利用逻辑中断判断一下，取重数组中不存在这个元素
 function res(arr) {

            var temp = []

            arr.forEach(function (item) {

                if (arr.indexOf(item) !== arr.lastIndexOf(item) && temp.indexOf(item) === -1) {

                    temp.push(item)

                }

            })

            return temp
        }

//方法2 双重for循环
function quchong(arr) {
            let arr2 = []
            for (let i = 0; i < arr.length; i++) {
                //第二个循环需要开始的下标比第一层循环大1
                for (let j = i + 1; j < arr.length; j++) {
                    //当两个元素相等，删除后面那个元素，此时数组长度减少，我们要j--，因为此时原本的下一个元素下标是j+1，而删掉了目前j这个下标元素，所以此时下个元素的下标也为j
                    if (arr[i] == arr[j]&& arr2.indexOf(arr[j]) == -1) {
                        arr2.push(arr[j])
                        arr.splice(j, 1)
                        j--
                        //此时我们取到的重复数组可能含有多项相同的,我们可以将这一项去掉，或者在最后用set去重
                        //arr = arr.filter(item => item != arr[j])
                    }
                }

            }
            
            return arr2
        }
        console.log(quchong(arr1))

```

#### 4.数组去重

```js
 const arr1 = [2, 6, 3, 2, 10, 5, 1, 2, 3, 1, 2, 3, 11]
      
//方法1，双重for循环
        for (let i = 0; i < arr1.length; i++) {
            //第二个循环需要开始的下标比第一层循环大1
            for (let j = i + 1; j < arr1.length; j++) {
                //当两个元素相等，删除后面那个元素，此时数组长度减少，我们要j--，因为此时原本的下一个元素下标是j+1，而删掉了目前j这个下标元素，所以此时下个元素的下标也为j
                if (arr1[i] == arr1[j]) {
                    arr1.splice(j, 1)
                    j--
                }
            }
        }
        console.log(arr1)

//方法2 利用set 配合Array.from方法或扩展运算符
       console.log([...new Set(arr1)])
      console.log(Array.from(new Set(arr1)))

//方法3，
     function unique(arr) {
            let array = []
            arr.forEach((item, index) => {
                if (!array.includes(item)) {//includes 检测数组是否有某个值
                    array.push(item)
                }
            })
            return array
        }
        console.log(unique(arr1))

//方法4  下面两种return原理是一样的，利用indexOf判断出来是符合条件的数组元素的第一个的下标，其他符合条件的下标忽略
   function qu(arr) {
            return arr.filter((item, index) => {
                return arr.indexOf(item) == index
                // return arr.findIndex(item1 => item1 == item) == index

            })
        }
```

#### 5.冒泡排序

```js
const arr1 = [1, 9, 10, 29, 5, 1, 7, 12]

        function pop(arr) {
 // 最外层实际循环了7次，为i=0，1，2，3，4，5，6的时候，这个数组实际长度为8，为什么是七轮对比，首先第一轮会确认下标为7的数组末尾为最大值，第二轮会确认下标为6的数组为第二大值，一直到第七轮可以确认下标为1的数组元素为倒数第二大的值，那么此时默认倒数第一的值了，所有是七轮对比
            for (let i = 0; i < arr.length - 1; i++) {
//每一次对比都是从下标为1的数组元素开始比较，注意，这里就是左右两个元素进行比较，如果前面大于后面则两者交换位置，然后j++，如果前面小于后面，那么位置不变j++，且当完整一轮对比结束，那么数组末尾处一定是最大的元素值，然后i++，此时进行下一轮从下标为1的数组元素开始向后对比，但是因为此时数组末尾已经是最大值，我们就不需要再进行对比了，所有我们的j循环的最大次数可以减去i，当第一轮对比完减去i为1，第二轮对比完减去i为2
                for (let j = 0; j < arr.length - 1 - i; j++) {
                    if (arr[j] > arr[j + 1]) {
                        let mid = arr[j + 1]
                        arr[j + 1] = arr[j]
                        arr[j] = mid
                    }
                }
            }
            return arr
        }
        console.log(pop(arr1))
```

#### 6.扁平化数组

```js
// 方法1，就是用flat方法，Infinity就是无限层扁平化
        const arr5 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
        let arr6= arr5.flat(Infinity);
       console.log(arr5);
        console.log(arr6);

        // 方法2 利用while 配合concat，因为concat可以合并数组和一些单个属性为一个新数组如concat（1，[2,3]） 结果为[1,2,3]   首先当some方法判断出数组某一个属性为数组返回true，while内部上下文触发，扩展运算符展开一层arr，然后下一次while循环循环的那个arr其实就是进行一次扁平化后的数组
        let arr4 = [1, [2, [3, 4]]];
        function flat(arr) {
            //此处循环用while，因为我们知道具体需要循环多少次，判断arr是否还存在子数组，存在就合并
            while (arr.some(item => Array.isArray(item))) {
      console.log(...arr);  //第一次arr展开是1, [2, [3, 4]]
     arr = [].concat(...arr) //所以第一次 arr=[].concat(1,[2,[3,4]]) ，也就是合并数字1和[2,[3,4]]这个数组
                console.log(arr, 'arr');//第一次合并成功的arr为[1,2,[3,4]]
            }
            return arr
        }
        console.log(flat(arr4));
```

#### 7.快速排序（相对来说最难的手搓）

```js
  // 这里的递归我可以这样理解 如果数组只要三个元素[2,1,3]，流程，数组长度大于1所以中为index=1，左为index=0，右为下标index=2的
        // 然后 return midSort(left).concat(midValue, midSort(right)) ；其中midSort(left)，数组left长度等于1，返回回去，midSort(right)
        // 同理，然后最终结果就是[1,2,3]，当数组元素很多时我们可以理解为无数个[2,1,3]组成的数组
        function midSort(arr) {
            //终止递归的条件,当需要拆分的数组只存在一个元素，也就是不需要进行拆分了，并返回出去	
            if (arr.length <= 1) {
                return arr
            };
            // Math.floor(arr.length/2)是同理
            let midIndex = parseInt(arr.length / 2),
               
                // 这里获取到的就是向取整的arr[midIndex]，因为index是0起始啊
                midValue = arr.splice(midIndex, 1);
            let left = [], right = [];
            // 大于中间值放入right数组，小于中间值放入left数组
            arr.forEach(item => {
                item < midValue ? left.push(item) : right.push(item)
            })
            return midSort(left).concat(midValue, midSort(right));//利用递归对left和right数组继续拆分
        }
        console.log(midSort([1, 2, 10, 5, 7, 2]));
// midIndex=3，midValue=5    left=[1,2,3,2]  right=[10,7] 
//所以return midSort([1,2,2]).concat(5, midSort([10,7]))
// 后面就好理解了  最前方midSort([1,2,3,2])    mid=3   left=[1,2,2]  right=[]
```

#### 8.最简单的数组乱序

```js
var arr = [1,2,3,4,5,6,7,8,9,10];
arr.sort(function(){
 return Math.random() - 0.5;
})
console.log(arr);
```



### 项目相关知识

在广西消防廉政档案里找找看有没有可以写在简历上的模块

广西消防廉政档案的信息采集中信息填报里的修改和新增去学习一下，（**重置的原理我还没用学记得看一下**）

这里的逻辑就是你点击的是修改的时候，将这一行的table栏的数据赋值给一个新的对象，这个对象并不是上面的表单对象，然后通过这个对象是否存在，存在就获取到这个对象内的id属性，提交时传递给后端，当你新增的时候，每一次返回的id都是一个固定值，而你修改的时候是将你拿到的那一行数据的和默认不一样的id传递给后端，后端通过id是否是默认，是默认id就是新增，如果id是数据库中某一个对象具有的，就修改那个对象的数据，新增修改是同一个接口。

![image-20240322144415744](assets/image-20240322144415744.png)



深圳编办项目的登录思路

这个系统是一个在编办工作台有一个总的登录页，如果直接没用登录去到其他系统会失败，会跳转到编办工作台的登录页进行登录，当你登录成功即可跳回你原本的那个系统，在编办工作台可以用location.href进行路由跳转到别的系统，当你登录成功，将后端返回的token利用会话存储或本地存储存储起来

#### 1.了解一下登录的逻辑

使用开源的加密库 crypto-js对密码进行加密，然后后端会用**CryptoJS**.AES.**decrypt**(  '5yOOaUK1NSxVcRc8TA1fZw==',）.toString()的方式进行解密，解密的数据就是明文密码通过加密生成的那个字符串

```js
//这里这个验证码是通过图片获取到，
//这是点击登录的逻辑
let aeskey = "Dp12345678123456";
//利用插件将密码加密
let pwd = CryptoJS.AES.encrypt(this.userLogin.password, aeskey).toString();

const data = {
  grant_type: 'password',
    //用户名
  username: this.userLogin.username,
    //密码
  usercode: pwd,
    //进行验证的通过图片输入的
  captcha: this.userLogin.vccode
};
this.showLoadding = true
try {
  const res = await this.$axios({
    url: 'zxcaptchalogin',//'locallogin',, //平台提供登录接口
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    params: data
  })
  console.log(res, 'res')
  if (!res.tokeninfo) {
    this.$message.error(res.message)
    this.num++
    this.showLoadding = false
    return
  }

  if (res.tokeninfo && res.userinfo) {
    this.$message.success('登录成功')
    sessionStorage.setItem("access_token", res.tokeninfo.access_token)
    sessionStorage.setItem("refresh_token", res.tokeninfo.refresh_token)
    sessionStorage.setItem("token", res.tokeninfo.access_token)
    sessionStorage.setItem("user", JSON.stringify(res.userinfo));

    this.showLoadding = false
    console.log(this.$route, '12132')
      //这里就是原本我们没用登录的时候自动跳转到登录页面，当我们输入账号密码登录成功，就会通过query绑定的这个字段进行路由跳转跳转回你原本未登录的页面
    this.$router.push(this.$route.query.redirect || '/')
  }
} catch (err) {
  this.showLoadding = false
  this.$message.error(err.message)
}
```

两个不关联的数据

![image-20240322141056261](assets/image-20240322141056261.png)

这里当我们输入以后，点击确认按钮需要正则判断，当输入符合要求就将这   个值赋给我们的文号，所以文号和输入框的数据是两个数据。如果设置成一个数据，那么你还没有进行判断这个值就动态给了文号框了   

#### 2.echarts地图自定义地图引入（有一个问题，深山合作区的经纬度其实是不对

利用geojson.io这个网站进行描点，获取到我们指定区域的经纬度的json字符串文件，然后给每个区域指定名字，如南山区

我这里可以将里面echarts的点击事件获取到我配置到区域 内部的name名字，也就是如宝安区，南山区这种区域，然后将这个区域利用store存储，在每个需要用到的模块利用computed获取到这个属性，然后监听这个值就可以做到点击不同区域，获取到不同区域的参数了

![image-20240320170658969](assets/image-20240320170658969.png)

![image-20240320162624115](assets/image-20240320162624115.png)



#### 3.创建百度地图的实例

![image-20240320205522564](assets/image-20240320205522564-17111750721491.png)

![image-20240320212207695](assets/image-20240320212207695-17111750721492.png)

引入真实的百度地图，首先是new一个百度地图辅助工具的实例 this.map=BMapGL.Map(),然后创建初始展示的点坐标的经纬度，这样地图初始化完成直接就会显示我们设置的经纬度那个坐标，我们使用的时候是利用展开树节点，初始的树节点是深圳的各个区，如深圳市，南山区，宝安区等，然后通过树形懒加载，当我们点击某一个区的时候获取到该区下的如党委系统，人大系统，政府系统之类的不同系统的分类，然后再点击会到具体所属单位，当我们点击时候，会获取到我们存储的指定每个单位的经纬度，然后利用百度地图的实例创建这个点var point = new BMapGL.Point(item.jd, item.wd);地图会立刻跳转经纬度到那个单位的位置，并展示单位的基本信息，如简介，还有电话等，然后点击这个单位的机构画像点击事件判断你是最后一级的节点，在路由上面利用query携带上你指定的单位名，跳转到这个单位的机构画像模块，并通过这个单位名这个模块发请求，从后端拿到这里指定的数据展示，在这里我们利用echarts展示了单位的人员分布，单位入编出编情况，在职人员的情况的echarts图，并且能够看到单位的历史沿革的的富文本。



#### 4后台管理系统中的权限管理是怎么实现的？（我做的那个是在仓库中进行判断，原理是类似的）

**登录：** 当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个 token，

拿到 token 之后（我会将这个 token 存贮到 cookie 中，保证刷新页面后能记住用户登录状态），前端会 根据 token 再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。

**权限验证：** 通过 token 获取用户对应的 权限，动态根据用户的 权限算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。

**具体思路：**

登录成功后，服务端会返回一个 **token**（该 token 的是一个能唯一标示用户身份的一个 key），之后我 们将 token 存储在本地 cookie 之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不 用再去登录页面重新登录了。

ps:为了保证安全性，我司现在后台所有 token 有效期(Expires/Max-Age)都是 Session，就是当浏览器关 闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新 token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账 号。

用户登录成功之后，我们会在全局钩子 router.beforeEach 中拦截路由，判断是否已获得 token，在 获得 token 之后我们就要去获取用户的基本信息了 页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有 token, 就会把这个 token 返给后端去拉取 user_info，保证用户信息是最新的。 当然如果是做了单点登录得功 能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登 录获取最新的内容。

先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登 录之后，通过 **token** 获取用户的 **role** ，动态根据用户的 role 算出其对应有权限的路由，再通过 **router.addRoutes** 动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是 绝对安全的，后端的权限验证是逃不掉的。

我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也 做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每 一个后台的请求不管是 get 还是 post 都会让前端在请求 header 里面携带用户的 token，后端会根据 该 token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状 态码，做出相对应的操作。 使用 vuex 管理路由表，根据 vuex 中可访问的路由渲染侧边栏组件。

**具体实现：**

创建 vue 实例的时候将**vue-router**挂载，但这个时候 vue-router 挂载一些登录或者不用权限的公用的页 面。

当用户登录后，获取用**role**，将 role 和路由表每个页面的需要的权限作比较，生成最终用户可访问的路 由表。

调用**router.addRoutes**(store.getters.addRouters)添加用户可访问的路由。

使用**vuex**管理路由表，根据 vuex 中可访问的路由渲染侧边栏组件。



#### 5.考试模块

[![image-20240401113711212](assets/image-20240401113711212.png)](https://github.com/ggbondddddd/4.1/blob/main/assets/image-20240401113711212.png)

[![image-20240401113651113](assets/image-20240401113651113.png)](https://github.com/ggbondddddd/4.1/blob/main/assets/image-20240401113651113.png)

1.在submit方法里，提交答案时，需要进行判断，因为单选和判断题的答案都是一个字符串，而多选则是一个数组，所有的题目是一个数组，然后每个题目选择的选项是数组中的每一个对象的一个属性，利用 Array.isArray(ele.value) ? ele.value.join(',') : ele.value,判断然后将用户选择的多选框的多选都变为变为字符串，单选则不变，因为本身就是字符串

2.然后利用submit里面定义的一个方法，判断答案是否正确，第一个参数是每一个对象的rigth属性（应该就是在给你请求回来题库的时候，答案已经在rigth字段携带过来了），我们通过用户选择的和这个正确答案进行对比，选出正确答案，并且有一点，这个判断里面利用了数组方法sort，应该是用来判断多选答案是否正确的吧

3.countdown方法，就是倒计时的时间戳，当倒计时结束，自动调用提交方法，向后端提交数据，哪怕你有的没有选

```js
<template>
  <div id="devhtml-lug8ck4x" class="div-HrtRBISd">
    <div class="div-nJ0vHL0J">
      <div class="div-3qpkLH4s">
        <span :contenteditable="false" class="span-p55mSIOU"> 共{{ tkList.length }}题，合计{{ total }}分 </span>
      </div>
      <div v-for="(item, index) in tkList" :key="index" :id="item.id" class="div-er91k4Pd">
        <div v-if="item.topic_type == '单选'" class="div-JjCouWKn">
          <div class="div-dE9jk0UD">
            <span :contenteditable="false" class="span-n4jzZDvy"> {{ index + 1 }} (单选题) {{ item.stem }} </span>
            <zx-icon
              icon="el-icon-star-off "
              v-if="!item.mark"
              @click="
                () => {
                  onClickIcon(item);
                }
              "
              class="zxIcon-O6YXcbjx click"
            >
            </zx-icon>
            <zx-icon
              icon="el-icon-star-on "
              v-if="item.mark"
              @click="
                () => {
                  onClickIcon2(item);
                }
              "
              class="zxIcon-Q2g57SMk click"
            >
            </zx-icon>
          </div>
          <zx-radio-field
            :is-field="true"
            :show-label="true"
            label-width="50px"
            item-value="value"
            item-label="label"
            item-disabled="disabled"
            bindlabel="label"
            bindvalue="value"
            :isbutton="false"
            layout="block"
            :options="item.options"
            v-model="item.value"
            :disabled="status == 0"
            class="zxRadioField-4a5aw0U7"
          >
          </zx-radio-field>
        </div>
        <div v-if="item.topic_type == '多选'" class="div-N7IRcXqG">
          <div class="div-2kTEknN3">
            <span :contenteditable="false" class="span-99V3mSYJ"> {{ index + 1 }} (多选题){{ item.stem }} </span>
            <zx-icon
              icon="el-icon-star-off "
              v-if="!item.mark"
              @click="
                () => {
                  onClickIcon(item);
                }
              "
              class="zxIcon-zlct9bqH click"
            >
            </zx-icon>
            <zx-icon
              icon="el-icon-star-on "
              v-if="item.mark"
              @click="
                () => {
                  onClickIcon2(item);
                }
              "
              class="zxIcon-jSBF7qAU click"
            >
            </zx-icon>
          </div>
          <zx-checkbox-field
            :show-label="true"
            :is-field="true"
            label-width="50px"
            item-value="value"
            item-label="label"
            item-disabled="disabled"
            bindlabel="label"
            bindvalue="value"
            layout="block"
            :options="item.options"
            v-model="item.value"
            :disabled="status == 0"
            class="zxCheckboxField-rtOGqjUH"
          >
          </zx-checkbox-field>
        </div>
        <div v-if="item.topic_type == '判断'" class="div-QzmxCiOm">
          <div class="div-AQgsrcAj">
            <span :contenteditable="false" class="span-4SoqqbnD"> {{ index + 1 }}(判断题){{ item.stem }} </span>
            <zx-icon
              icon="el-icon-star-off "
              v-if="!item.mark"
              @click="
                () => {
                  onClickIcon(item);
                }
              "
              class="zxIcon-y1ZRxq6l click"
            >
            </zx-icon>
            <zx-icon
              icon="el-icon-star-on "
              v-if="item.mark"
              @click="
                () => {
                  onClickIcon2(item);
                }
              "
              class="zxIcon-17pEQzNg click"
            >
            </zx-icon>
          </div>
          <zx-radio-field
            :is-field="true"
            :show-label="true"
            label-width="50px"
            item-value="value"
            item-label="label"
            item-disabled="disabled"
            bindlabel="label"
            bindvalue="value"
            :isbutton="false"
            layout="block"
            :options="item.options"
            v-model="item.value"
            :disabled="status == 0"
            class="zxRadioField-5HtB6EK4"
          >
          </zx-radio-field>
        </div>
        <div v-if="status == 0 && item.isCorrect" class="div-lJBpunEv">
          <div class="div-6uVbWcDZ">
            <zx-icon icon="el-icon-success " class="zxIcon-FX3ORnqF"> </zx-icon>
            <span :contenteditable="false" class="span-653AHS7R"> 恭喜您，您答对了 </span>
          </div>
          <div class="div-FtAxHqf9">
            <span :contenteditable="false" class="span-nTjgC9vI mr"> 本题分数：{{ item.score }} </span>
          </div>
          <div class="div-f2UBoF92">
            <span :contenteditable="false" class="span-uczd7LAf mr"> 学员答案：{{ item.answererAnswer }} </span>
          </div>
          <div class="div-2AEiduaX">
            <span :contenteditable="false" class="span-Ex6V2aJU mr"> 正确答案：{{ item.rigth }} </span>
          </div>
        </div>
        <div v-if="status == 0 && !item.isCorrect" class="div-ABAgFylF">
          <div class="div-tB3mSaYG">
            <zx-icon icon="el-icon-error " class="zxIcon-jrrXRESS"> </zx-icon>
            <span :contenteditable="false" class="span-f3l0CLMD"> 很遗憾，您答错了 </span>
          </div>
          <div class="div-SEegNxgD">
            <span :contenteditable="false" class="span-8i2rvdPr mr"> 本题分数：{{ item.score }} </span>
          </div>
          <div class="div-u4vgCED2">
            <span :contenteditable="false" class="span-df6Eo54m mr"> 学员答案：{{ item.answererAnswer }} </span>
          </div>
          <div class="div-U3VpO16C">
            <span :contenteditable="false" class="span-9r3yfMKk mr"> 正确答案：{{ item.rigth }} </span>
          </div>
        </div>
      </div>
    </div>
    <div class="div-wjZxBIHq">
      <div v-if="status == 0" class="div-kYZYAka9">
        <span :contenteditable="false" class="span-sly2b4D3"> 考试成绩: </span>
        <span :contenteditable="false" class="span-9m5hu9tF"> {{ score }} </span>
      </div>
      <div v-if="status == 0 && $route.query.score_line" class="div-z9EV9OSo">
        <span :contenteditable="false" class="span-t4o8rB4A"> 考试结果: </span>
        <span :contenteditable="false" class="span-LLABuEx4"> {{ result }} </span>
      </div>
      <div class="div-J5W3gnvX">
        <div v-if="status == 1" class="div-eOg05Jrw">
          <span :contenteditable="false" v-if="countdownValue" class="span-JMtuHIfU"> 剩余时间: </span>
          <span :contenteditable="false" v-if="countdownValue" class="span-Fo9cdHbt"> {{ countdownValue }} </span>
        </div>
        <zx-button type="primary" :plain="true" size="mini" @click="btnClick" class="zxButton-K0I9psXS"> 退出考试 </zx-button>
      </div>
      <div class="div-LoV4gMaR">
        <span :contenteditable="false" class="span-49E1LUDQ"> 当前进度: </span>
        <span :contenteditable="false" class="span-N8M0diSN"> {{ currentNum }}/{{ tkList.length }} </span>
      </div>
      <div class="div-YzKiTDnN">
        <span :contenteditable="false" class="span-uOIxur4s"> 答题卡 </span>
      </div>
      <div class="div-I0eiR0o7">
        <span :contenteditable="false" class="span-xI6XyBPB"> 共{{ tkList.length }}题，合计{{ total }}分 </span>
      </div>
      <div class="div-LXcRcc7c">
        <div
          v-for="(item, index) in tkList"
          :key="index"
          @click="
            () => {
              onClickDiv(item);
            }
          "
          class="div-nXXG0MmG"
        >
          <span :contenteditable="false" :class="status == 0 ? (item.isCorrect ? 'success' : 'error') : item.value && item.value.length ? 'active' : ' '" class="span-dXRusDoG">
            {{ index + 1 }}
          </span>
          <zx-icon icon="el-icon-star-on " v-if="item.mark" class="zxIcon-twwUjQj8"> </zx-icon>
        </div>
      </div>
      <div class="div-JQSyw2rG">
        <zx-button type="primary" :plain="true" size="mini" v-if="status == 1" @click="submit" class="zxButton-zmGnBUxt"> 提交试卷 </zx-button>
        <div class="div-jSKyho1l"></div>
        <span :contenteditable="false" class="span-FQTcAzqL"> 已答 </span>
        <div class="div-cqrwRLvO"></div>
        <span :contenteditable="false" class="span-gcjWPWYR"> 未答 </span>
        <zx-icon icon="el-icon-star-on " class="zxIcon-GRttaVgX"> </zx-icon>
        <span :contenteditable="false" class="span-4Ba6FZDZ"> 标记 </span>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      self: this,
      tkList: [],
      status: "1",
      total: 0,
      currentNum: 0,
      user: zxUtils.getSessionStorageItem("false", "object"),
      score: 0,
      result: "",
      countdownValue: 0,
      intervalId: 0,
      startTime: "",
    };
  },

  watch: {
    tkList: {
      handler: function (newVal, oldVal) {
        console.log(newVal);

        this.currentNum = 0;
        this.tkList.forEach((ele) => {
          if (ele.value && ele.value.length) {
            this.currentNum++;
          }
        });
      },
      deep: true,
    },
    countdownValue: {
      handler: function (newVal, oldVal) {
        if (newVal == "提交") {
          this.submit();
        }
      },
    },
  },

  methods: {
      //初始化渲染考试，有单选，多选，判断题
    initData() {
      if (this.$route.query.topic_basic_id) {
        this.$axios({
          url: `${globalEnv.API}/examination/getRandomTopic`,
          method: "get",
          params: { id: this.$route.query.id },
        })
          .then((res) => {
            this.tkList = res.data;
            this.total = 0;
            //这是具体遍历的包含单选 多选 判断的题目，以及每一个选项
            this.tkList.forEach((ele, index) => {
              this.total += Number(ele.score);
                //此处label里面的a,b,c,d,e,f的意思就是从后端拿来的每一个对象,将这个对象的属性a,b,c,d,e,f的属性赋值给label，但是可能有的选择题没有e，f选项，我们就看下面注释，这个option就是我们单选组复选组的选项，下方利用$set创建的那个value属性，属性值为空的对象属性就是用户具体选择的选项
              ele.options = [
                { label: ele.a, value: "A" },
                { label: ele.b, value: "B" },
                { label: ele.c, value: "C" },
                { label: ele.d, value: "D" },
                { label: ele.e, value: "E" },
                { label: ele.f, value: "F" },
              ];
                //过滤出存在lebel的选项，因为label如果为空，判断为false，会被过滤掉
              ele.options = ele.options.filter((ele) => {
                return ele.label;
              });
              this.$set(ele, "value", "");
              this.$set(ele, "mark", false);
              // if (topic_type = "单选") {
              //   ele.score = ele.danxt_score

              // }
              // if (topic_type = "多选") {
              //   ele.score = ele.danxt_score
              // }
              // if (topic_type = "判断题") {
              //   ele.score = ele.danxt_score
              // }
            });

            this.$axios({
              url: `${globalEnv.API}/fstj/exam/getResultByUserIdAndExamId`,
              method: "get",
              params: { exam_id: this.$route.query.id },
            }).then((res) => {
              if (res.data && res.data.comtent) {
                console.log(JSON.parse(res.data.comtent));
                this.tkList = JSON.parse(res.data.comtent).topicIsSuccessDtos;
                this.score = JSON.parse(res.data.comtent).point;
                if (Number(this.score) > Number(this.$route.query.score_line)) {
                  this.result = "通过";
                } else {
                  this.result = "未通过";
                }

                this.status = 0;
              }
            });
            console.log("this.tkList", this.tkList);
          })
          .catch((err) => {
            this.$message.error(err.message);
          });
      }
    },
    submit(item) {
      console.log("this.tkList", this.tkList);

      this.status = 0;

      const topicIsSuccessDtos = this.tkList.map((ele) => {
        let newValue = ele.value;
        return {
          ...ele,
          answererAnswer: Array.isArray(ele.value) ? ele.value.join(",") : ele.value,
          id: ele.id,
          isCorrect: areStringsEqualRegardlessOfOrder(ele.rigth, Array.isArray(ele.value) ? ele.value.join(",") : ele.value),
          score: ele.score,
          rigth: ele.rigth,
        };
      });

      const point = topicIsSuccessDtos.reduce((p, c) => {
        console.log("OOOOOOO", c, p);
        if (c.isCorrect) {
          return Number(c.score) + Number(p);
        } else {
          return Number(p);
        }
      }, 0);

      const result = { point, topicIsSuccessDtos };

      const data = {
        exam_id: this.$route.query.id,
        score: point,
        comtent: JSON.stringify(result),
        publish_time: this.startTime,
        total_score: this.total,
        topic_count: this.tkList.length,
        exam_name: this.$route.query.exam_name,
        topic_name: this.$route.query.topic_name,
        topic_basic_id: this.$route.query.topic_basic_id,
        answer_time: this.$route.query.answer_time,
        score_line: this.$route.query.score_line,
      };

      // /examination/addAndModify
      console.log("topicIsSuccessDtos", result);

      this.$axios({
        url: `${globalEnv.API}/fstj/exam/saveOrUpdate`,
        method: "post",
        data,
      })
        .then((res) => {
          location.reload();
          console.log("res");
        })
        .catch((err) => {
          this.$message.error(err.message);
        });

      function areStringsEqualRegardlessOfOrder(str1, str2) {
        const arr1 = str1.split(",").sort();
        const arr2 = str2.split(",").sort();

        return JSON.stringify(arr1) === JSON.stringify(arr2);
      }
    },
    onClickIcon(item) {
      item.mark = true;
    },
    onClickIcon2(item) {
      item.mark = false;
    },
    btnClick(item) {
      this.$router.go(-1);
    },
    countdown() {
      function padZero(number) {
        return number < 10 ? `0${number}` : `${number}`;
      }

      let countdown = (minutes) => {
        // 将分钟数转换为毫秒数
        const milliseconds = Number(minutes) * 60 * 1000;

        // 获取目标时间（当前时间 + 毫秒数）
        const targetTime = new Date().getTime() + milliseconds;

        // 更新倒计时的显示
        function updateCountdown() {
          const currentTime = new Date().getTime();
          const timeDifference = targetTime - currentTime;

          // 计算剩余的分钟和秒
          let remainingHours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          let remainingMinutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60));
          let remainingSeconds = Math.floor((timeDifference % (1000 * 60)) / 1000);

          remainingHours = padZero(remainingHours);
          remainingMinutes = padZero(remainingMinutes);
          remainingSeconds = padZero(remainingSeconds);

          // 如果倒计时结束，清除定时器
          if (timeDifference <= 0) {
            clearInterval(this.intervalId);
            return "提交";
          }

          return `${remainingHours}:${remainingMinutes}:${remainingSeconds}`;
        }

        // 初始调用一次以防止页面加载时的延迟
        updateCountdown();

        // 每秒更新一次倒计时
        this.intervalId = setInterval(() => {
          this.countdownValue = updateCountdown();
        }, 1000);
      };

      const minutesToCountdown = this.$route.query.answer_time;

      function isNumericString(str) {
        // 使用正则表达式检查字符串是否只包含数字
        return /^\d+$/.test(str);
      }

      if (isNumericString(minutesToCountdown)) {
        // 启动倒计时
        countdown(Number(minutesToCountdown));
        // setInterval(() => {
        //     console.log(this.countdownValue)
        // }, 1000)
      }
    },
    destroy() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
      }
    },
    onClickDiv(item) {
      let elements = document.getElementById(item.id);
      if (elements) elements.scrollIntoView({ behavior: "smooth" });
    },
    getTime() {
      const now = new Date();

      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, "0");
      const day = String(now.getDate()).padStart(2, "0");

      const hours = String(now.getHours()).padStart(2, "0");
      const minutes = String(now.getMinutes()).padStart(2, "0");
      const seconds = String(now.getSeconds()).padStart(2, "0");

      this.startTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    },
  },

  created() {
    this.initData();
  },

  mounted() {
    this.countdown();
    this.getTime();
  },

  destroyed() {
    this.destroy();
  },
};
</script>
```



#### 树形懒加载的流程（广西消防廉政档案）



[![image-20240401155437781](assets/image-20240401155437781.png)](https://github.com/ggbondddddd/4.1/blob/main/assets/image-20240401155437781.png)

圈住的就是懒加载的核心

[![image-20240401161304016](assets/image-20240401161304016.png)](https://github.com/ggbondddddd/4.1/blob/main/assets/image-20240401161304016.png)

```js
methods:{
    function queryOrg(id){
        this.currentid = ''
this.currentName = ''

        //这一步拿到的是一个我不知道有啥用的东西，我也不知道有啥用，貌似和懒加载无关
const res = await this.$axios({
  url: `/userresource/ent/api/getDeptListByEntUserId?userId=${this.user.userid}`,
  method: 'get',
})
//这一步有些不太明白
if (res.data) {
  const deptArray = res.data[0].idlevel.split('_')
  const nameArray = res.data[0].ssdeptname.split('/')

  if (deptArray.length && deptArray.length > 1) {
    this.currentid = deptArray[1]
    this.currentName = nameArray[1]
  } else {
    this.currentid = deptArray[0]
    this.currentName = nameArray[0]
  }

  if (nameArray[1] == '机关处室') {
    this.currentid = deptArray[0]
    this.currentName = nameArray[0]
  }

  this.expandArr = [this.currentid]
}


//这里就是获取到你点击节点的所有子节点及其具体信息
const params = {
  type: 'o',
  pid: 0,
  queryParam: ''
}
if (id) params.pid = id
else params.pid = this.currentid
// params.queryParam = '广西消防总队'
return this.$axios({
  url: '/userresource/complexQueryApi/queryComplexList',
  method: 'get',
  params
}).then(res => {
  console.log("res.data", res.data)
  return res.data
})
    }
}

//获取具体某个节点所包含的人员信息
function queryMemberList(id){
this.$axios({
  url: '/userresource/entUser/api/getEntDeptUserList',
  method: 'get',
  params: {
    pageNum: this.pageData.pageNum,
    pageSize: this.pageData.pageSize,
    deptId: id,
    hassub: 0,
    // entId: id,
    access_token: sessionStorage.getItem('access_token'),
    queryStr: this.form.queryStr ? this.form.queryStr : null,
    deptname: this.form.deptname ? this.form.deptname : null
  }
}).then(res => {

  this.pageData = {
    ...this.pageData,
    list: res.data ? res.data.list : [],
    total: res.data ? res.data.total : 0,
  }
})
}

//这是卓迅的树形组件内置的懒加载方法，当懒加载的时候会调用，默认初始化页面会调用一次
function treeload(node,resolve){
    //这个data可以获取到我们点击的那个节点的一些属性，包含这个节点的子节点及子节点的一些属性
    const data = node.data
console.log("MMMMUUUU", node)
this.queryOrg(data.id).then(res => {
  if (!this.defaultSelectOrgId && res.length) {
    //this.defaultSelectOrgId = res[0].id
    if (!data.id) {
      this.defaultSelectOrgId = this.currentid
    } else {
      this.defaultSelectOrgId = res[0].id
    }
      //获取具体节点的人员信息
    this.queryMemberList(this.defaultSelectOrgId)
    let treeNode = {
      type: "o",
      id: this.currentid,
      name: this.currentName,
      children: res
    }
    //这个地方记住啊，orgList就是我们树形绑定数据，这里是我们初始化页面的时候默认展开第一级，将第一级和第二级数据绑定在树形上
    this.orgList = [treeNode]
    console.log("this.orgList", this.orgList)
  }
  resolve(res.map(item => {
    return {
      ...item,
      leaf: item.type === 'u'
    }
  }))
})
}

//内置的树形点击事件，点击某一个节点就调用获取具体人员信息的方法
function nodeClick(value,node,data){
    // 将你点击的那个树节点的id传给接口
this.selectOrgId = value.id
this.queryMemberList(this.selectOrgId)
}
```



#### 6.新增还是修改判断



[![image-20240401173613471](assets/image-20240401173613471.png)](https://github.com/ggbondddddd/4.1/blob/main/assets/image-20240401173613471.png)

此处的新增和修改是同一个接口，然后当我们点击表格的编辑的时候，就会将我们点击的这一行，也就是这个row赋给一个变量，然后点击保存时候进行判断，当这个变量存在，在给接口传递字段的时候多传递一个这个row的id，就证明我是修改；而新增就不传递这个id，以此来判断

[![image-20240401174219715](assets/image-20240401174219715.png)](https://github.com/ggbondddddd/4.1/blob/main/assets/image-20240401174219715.png)



7.点击预览图片或者文档

![img](assets/wps1.jpg) 

```js
//点击预览的这个事件
let url = window.location.origin + `/faas/fileapi/download/FastDFS/${row.id}`

const downloadFile = (url, fileName, params = {}) => {
 const queryString = Object.keys(params)
  .map(
   (key) =>
  `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`
  )
.join("&");
 if (queryString) {
  url += `?${queryString}`;
 }
 const request = new XMLHttpRequest();
 request.responseType = "blob";
 // console.log(url)
 request.open("get", url, true);

 // request.open("post", url, true);

 let tk = sessionStorage.getItem('access_token')

 // request.setRequestHeader('Content-Type', 'multipart/form-data;charset=utf-8');

 request.setRequestHeader("Authorization", `Bearer ${tk}`);

 request.onreadystatechange = (e) => {
  if (
   request.readyState == XMLHttpRequest.DONE &&
   request.status == 200
  ) {
   this.imgLits = [URL.createObjectURL(request.response)]
   this.show = true
  }
 };
 request.send(null);
 const download = (url, name) => {
  const aLink = document.createElement("a");
  aLink.download = name;
  aLink.href = url;
  aLink.dispatchEvent(new MouseEvent("click", {}));
 };
}
if (row.subfix == '.png' || row.subfix == '.jpge' || row.subfix == '.jpge' || row.subfix == '.jpg' || row.subfix == '.webp' || row.subfix == '.gif' || row.subfix == '.svg') {
 downloadFile(url, row.filename)
} else if (row.subfix == '.pdf') {
 const data = {
  fileid: row.id,
  transformPdf: 'true',
  watermarkConfig: {},
 };
 this.$axios.post('/faas/queryPerviewTempId', data).then((res) => {
  window.open('/faas/api/perview?transformPdf=true&fileid=' + res.data)
 });
} else if (row.subfix == '.docx' || row.subfix == '.doc') {
 const data = {
  fileid: row.id,
  filetype: 'word',
  transformPdf: 'true',
  watermarkConfig: {},
 };
 this.$axios.post('/faas/queryPerviewTempId', data).then((res) => {
 window.open('/faas/api/perview?transformPdf=true&fileid=' + res.data)
 });
}
else {
 window.open(`/faas/fileapi/download/FastDFS/${row.id}`)
}

这是点击表格的下载的事件
function downloadFile() {
 const fileId = row.id;
 const fileName = row.filename; // 你的文件名

 // 创建一个隐藏的<a>元素
 const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);

 let tk = sessionStorage.getItem('access_token')

 // 发起 GET 请求以获取文件内容
 fetch(`/faas/fileapi/download/FastDFS/${fileId}`, {
  method: 'GET',
  headers: {
   'Authorization': `Bearer ${tk}`
  }
 })
  .then(response => response.blob())
  .then(blob => {
   // 创建一个 Blob 对象，并设置文件类型
   const file = new Blob([blob], { type: 'application/octet-stream' });


   // 创建下载链接

   const fileUrl = window.URL.createObjectURL(file);
   link.href = fileUrl;
   link.setAttribute('download', fileName);

 
   // 模拟用户点击下载链接
   link.click();
   // 清理资源
   window.URL.revokeObjectURL(fileUrl);
  })
  .catch(error => {
   console.error('Error fetching file:', error);
  });
}
downloadFile()
```

#### 7.点击头像上传的做法

```js
很好理解，点击那个图片，我们将利用display:none隐藏的那个
上传文件组件获取到，触发其点击事件，那么就可以上传，
图片点击事件：
let inp = document.querySelector('.el-upload__input')
//我的理解是利用display：none隐藏的元素，还可以依然可以触发点击事件
inp.click()
然后可以上传文件，上传文件成功之后我们再获取上传的这个图片，
将这个图片地址放在现在展示头像图片的地方即可。
this.$axios({
  url: `${globalEnv.api}/steam/fileAdd`,
  method: 'post',
  data: {
    id: this.$route.query.id, filelist: this.filelist.map(ele => {
      return {
        originname: ele.filename,
        fileid: ele.id,
        filesize: ele.filesize
      }
    })
  }
}).then(res => {
//这里是获取到新上传的图片地址，然后替换当前头像图片
  let params = {
  id: this.$route.query.id
}
this.$axios({
  url: `${globalEnv.api}/steam/fileList`,
  method: 'get',
  params: params
}).then(res => {
  const filelist = res.data.map(ele => {
    return {
      ...ele,
      fileid: ele.file_id,
      filesize: ele.file_size,
      filename: ele.origin_name
    }
  })

  let newestObject = filelist.reduce((prev, current) => {
    // 将日期字符串转换为 Date 对象进行比较
    let prevDate = new Date(prev.create_time);
    let currentDate = new Date(current.create_time);

    // 比较日期，返回最新的对象
    return (prevDate > currentDate) ? prev : current;
  });

  let id = newestObject.fileid
  console.log("newestObject", newestObject)
  let tk = sessionStorage.getItem('access_token')
  this.imgUrl = `/faas/fileapi/download/FastDFS/${id}?access_token=${tk}`
})

  this.$message.success('操作成功')
})
```

#### 	8.鼠标移入移出显示对应模块

![image-20240410132405057](assets/image-20240410132405057.png)

实现效果就是，，模块a是循环出来的，当我鼠标触摸模块a得某一项，如编制，以移出的形式展示编制对应的那个模块b，然后这个模块b的每一项都对应不同的路由。  原理就是子绝父相，模块b是子绝对定位，然后利用转换向x左侧移动到可视窗口外，当我们触摸就会展示出来，鼠标移出又会显示，这个效果使用过渡实现的，整个模块a对应的模块b也是遍历出来的，分别给如编制，机构依次的的模块b加上类名index+1，然后我们触摸如编制就展示出类名为index1的这个模块b，我们触摸机构就展示index2这个类名的模块b，然后模块b触摸高亮就是利用动态的 index==’1‘，之类的来进行添加的。